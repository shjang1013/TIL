# List1
*written by sohyeon*🍀

<br>

## 1. 알고리즘
### 알고리즘
유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

### 알고리즘 표현법
* 슈도코드 : 일반적인 언어로 코드를 흉내 내에 알고리즘을 써 놓은 코드  
  
* 순서도 : 프로그램이나 작업의 진행 흐름을 순서에 따라 여러 가지 기호나 문자로 나타낸 도표  
  
  ### 무엇이 좋은 알고리즘인가?
* 정확성 : 얼마나 정확하게 동작하는가?  
* 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가?  
* 메모리 사용량 : 얼마나 적은 메모리를 사용하는가?  
*  단순성 : 얼마나 단순한가?  
*  최적성 : 더 이상 개선할 여지 없이 최적화되었는가?  
  
  ### 시간복잡도
  빅-오(O) 표기법과 비슷하며, 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
  계수(Coefficient)는 생략하여 표시
 
<br> 
  
## 2. List
### 파이썬(Python)
* 인터프리어 언어로 독립적인 플랫폼
* 객체지향
* IoT분야의 라즈베리파이, 최근 빅데이터의 자료분석 등에서 파이썬의 관심이 높아짐

### 변수
* 파이썬에서는 모든 자료는 객체
    * Java나 C에서 사용되는 기본형 타입 변수도 파이썬에서는 객체
* 변수의 선언은 따로 없음
    * 변수에 값을 초기화 시 변수가 메모리에 생성

### 자료형
다수의 데이터를 저장할 수 있는 컨테이너  
| 종류 | 기호 | 순서 | 중복 | 데이터변경 | 비고 |
|:---:|:---:|:---:|:---:|:---:|:---:|
| tuple | ( ) | O | O | X | 수의 나열은 tuple로 인식<br>packing, unpacking |
| list | [ ] | O | O | O | |
| dictionary | { } | X | 키의 중복 X<br>값의 중복 O | O | 키 : 값의 구조로 저장<br>키는 불변 객체만 | 
| set | { } | X | X | O | 불편 객체만 저장 가능 | 불변 객체만 저장 가능 |

### 리스트(List)
다양한 데이터를 저장할 수 있으며, 크기를 가변적으로 변경할 수 있음

### 함수와 연산
| 함수 | 설명 | 예시 | 결과 | 
|:---:|:---:|:---:|:---:|
| `len()` | 원소 개수 | len([ 2, 3, 4 ]) | 3 |
| ` + ` | 시퀀스 연결 | [ 1, 2, 3 ] + [ 4, 5 ] | [ 1, 2, 3, 4, 5 ] | 
| ` * ` | 반복 | [ 1, 2 ] * 2 | [ 1, 2, 1, 2 ] |
| ` in ` | 소속하는지 | 2 in [ 1, 2, 3 ] | True |
| `not in` | 소속하지 않은지 | 2 not in [ 1, 2, 3 ] | False |
| `min()` | 원소 중 최소값 | min([ 1, 2, 3 ]) | 1 |
| `max( )` | 원소 중 최대값 | max([ 1, 2, 3 ]) | 3 |
| `sorted()` | 정렬된 리스트 반환 | a = [ 3, 1, 2 ]<br>print(sorted(a)) | [1, 2, 3] |
| `append()` | 리스트 끝에 추가 | a = [ 1, 2 ]<br>a.append(3) | [ 1, 2, 3 ] |
| `insert()` | 해당 위치에 삽입 | a = [ 3, 4, 5 ]<br>a.insert(1, 9) | [ 3, 9, 4, 5 ] |
| `pop()` | 특정 index 항목 삭제 | a = [ 3, 4, 5 ]<br>a.pop(1) | [ 3, 5 ] |
| `remove()` | 특정 값을 삭제(첫 번째 요소만) | a = [ 3, 4, 5 ]<br>a.remove(4) | [ 3, 5 ]
| `count()` | 일치하는 값의 개수 | a = [ 9, 4, 4, 9, 5, 9 ]<br>a.count(9) | 3 |

<br>

## 3. Exhaustive Search

### 완전 검색(Exhaustive Search)
문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법  
* Brute-force 혹은 Generate-and-Test 기법이라고도 불림
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출함
* 일반적으로 경우의 수가 상대적으로 작을 때 유용함
* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
* 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함

#### ex) Baby-gin 게임
```
1. 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplete이라고 함
2. 6장의 카드가 run과 triplete로만 구성된 경우를 Baby-gin으로 부름
```

#### ex) 6자리의 숫자를 입력 받아 Baby-gin 여부 찾기
```
1. 고려할 수 있는 모든 경우의 수 생성하기
    > 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
2. 해답 테스트하기
    > 앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함
```

### 순열(Permutation)
서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것  
* 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현 : `nPr`
* nPr은 다음과 같은 식이 성립 : `nPr = n * (n-1) * (n-2) * ... * (n-r+1)`

#### ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수
동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop을 이용
```
for i in range(1,4):
    for j in range(1,4):
        if j != i:
            for k in range(1,4):
                if k != i and k != j:
                    print(i, j, k)
```
<br>

## 4. Greedy Algorithm

### 탐욕 알고리즘(Greedy Algorithm)
최적 해를 구하는데 사용되는 근시안적인 방법
* 여러 경우 중 하나를 결정해야 할 때마다 `그 순간을 최적이라고 생각되는 것을 선택해 나가는 방식`으로 진행하여 최종적인 해답에 도달함
* 일단적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 `Greedy 접근`이 됨

### 탐욕 알고리즘의 수행 과정
```
1. 해 선택
    > 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합(Solution Set)에 추가함
2. 실행 가능성 검사
    > 새로운 부분 해 집합이 실행 가능한지를 확인
    > 곧, 문제의 제약 조건을 위반하지 않는지를 검사함
3. 해 검사
    > 새로운 부분 해 집합이 문제의 해가 되는지를 확인
    > 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작함
```

#### ex) 거스름돈 줄이기
어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?
```
1. 해 선택
    > 가장 좋은 해를 선택
    > 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가함
2. 실행 가능성 검사
    > 거스름돈이 손님에게 내드려야 할 액수를 초과하는지를 확인
    > 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가함
3. 해 검사
    > 거스름돈이 손님에게 내드려야 하는 액수와 일치하는지 확인
    > 액수에 모자라면 다시 해 선택으로 돌아가서 거스름돈에 추가할 동전을 고름
```

#### 완전 검색이 아닌 Baby-gin 방법으로 풀기
```
1. 6개의 숫자는 6자리의 정수 값으로 입력됨
2. COUNTS 리스트의 각 원소를 체크하여 run과 triplete 및 Baby-gin 여부를 판단함
    > 탐욕 알고리즘을 적용함
    > COUNTS 리스트에서 run과 triplete 중에 가능한 것을 조사함
    > 조사에 사용한 데이터는 삭제함
    > 남은 데이터를 다시 run과 triplete 중에 가능한지를 조사함
```

<br>

## 5. Sort

### 정렬(Sort)이란?
2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것
* 키란 자료를 정렬하는 기준이 되는 특정 값

정렬에는 `버블정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬` 등이 있다.  

### 버블 정렬(Bubble Sort)
인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식  
  
* 정렬 과정 `시간 복잡도 = O(n^2)`  
```
1. 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
2. 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨
3. 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양 같아서 버블 정렬이라고 함
```

#### ex) 리스트를 활용한 버블 정렬
```
def BubbleSort(a): # 정렬할 List
    for i in range(len(a)-1, 0, -1): # 범위의 끝 위치
        for j in range(0, i):
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

### 카운팅 정렬(Counting Sort)
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘  
  
* 정렬 과정 `시간 복잡도 = O(n+k) : n은 리스트의 개수, k는 정수의 최대값`
    * 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능  
    각 항목의 발생 횟수를 기록하기 위해, 정수 항목으로 인덱스되는 카운트들의 리스트를 사용하기 때문임
    * 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
```
{0, 4, 1, 3, 1, 2, 4, 1}을 카운팅 정렬하는 과정

1. Data에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트 COUNTS에 저장
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정
3. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
4. COUNTS[4]를 감소시키고 TEMP에 4를 삽입
5. COUNTS[2]를 감소시키고 TEMP에 2를 삽입
6. COUNTS[1]을 감소시키고 TEMP에 1을 삽입
...

11. TEMP 업데이트 완료하고 정렬 작업을 종료
```

#### ex) 카운팅 정렬
```
def CountingSort(A,B,k):
# A[1..n] : 입력 리스트 사용된 숫자(1~k)
# B[1..n] : 정렬된 리스트
# C[1..k] : 카운트 리스트

    C = [0] * k
    
    for i in range(0, len(B)):
        C[A[i]] += 1
    
    for i in range(1, len(C)):
        C[i] += C[i-1]
        
    for i in range(len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1

a = [0, 4, 1, 3, 1, 2, 4, 1]
b = [0] * len(a)
CountingSort(a,b,5)
print(b)
```

### 버블 정렬과 카운팅 정렬의 특성 비교
| 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
|:---:|:---:|:---:|:---:|:---:|
| 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉬움 |
| 카운팅 정렬 | O(n+k) | O(n+k) | 비교환 방식 | n이 비교적 작을 때만 가능 |
  
<br>

## Reference & Additional Resources
> SW Expert Academy  
