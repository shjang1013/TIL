# 시작하기
*written by sohyeon*🍀

<br>

## 1. SW 문제 해결

### 프로그래밍
`프로그래밍을 잘하는 사람과 못하는 사람의 생산성 차이는 20배`

* 프로그래밍하기 위한 제약 조건과 요구사항
    - 프로그래밍 언어의 특성
    - 프로그램이 동작할 H/W와 OS에 관한 지식
    - 라이브러리들이 유의 사항들
    - 프로그램이 사용할 수 있는 최대 메모리
    - 사용자 대응 시간 제한
    - 재사용성이 높은 간결한 코드
    
### SW 문제 해결 역량
프로그램 작성을 위한 많은 `제약 조건들과 요구사항들을 이해`하고 `최선의 방법을 찾아내는 능력`

* 프로그래머가 사용하는 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 `적재적소에 연결하여 큰 그림을 만드는 능력`
* 문제 해결 역량은 `추상적인 기술`
    - 명확히 정의된 실체가 없음
    - 알고리즘들을 암기하고 문제를 풀어본다고 향상되지 않음
* 문제 해결 역량 향상을 위해서 훈련 필요

### 문제 해결 능력을 향상시키는 훈련
* 새로운 언어, 프레임워크, 개발 방법론들의 `조합 방법을 배워야 함`
* 프로그래밍 경험을 통해서 나아질 것이라는 기대를 하지 않아야 함
    - 경험에서 문제 해결 능력 개발 가능한 상황이 항상 주어지지 않음
    - 문제 해결 능력 개발 가능한 상황에서 자기 계발하기 어려움
* `인위적 상황을 만들어 훈련`해야 함
    - `정제된 추상적인 문제를 제시`하고 해결하면서 문제 해결 능력을 향상시킬 수 있는 `훈련 필요`
    
### 문제 해결 과정    
```
1. 문제를 읽고 이해하기
2. 문제를 익숙한 용어로 재정의하기
3. 어떻게 해결할지 계획 세우기
4. 계획 검증하기
5. 프로그램으로 구현하기
6. 풀이를 돌아보고, 개선할 방법 찾기
```

### 문제 해결 전략
`직관`과 `체계적`인 접근

* 체계적인 접근을 위한 질문들
    - 비슷한 문제를 풀어본 적이 있던가?
    - 단순한 방법에서 시작할 수 있을까?
    - 문제를 단순화 할 수 있을까?, 그림으로 그려볼 수 있을까?, 수식으로 표현할 수 있을까?
    - 문제를 분해할 수 있을까?
    - 뒤에서부터 생각해서 문제를 풀 수 있을까?
    - 특정 형태의 답만을 고려할 수 있을까?

<br>

## 2. 알고리즘 복잡도
### 알고리즘
유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

### 알고리즘의 효율
같은 문제에 대한 다른 알고리즘들이 구현되어 컴퓨터에서 실행되는 경우 `입력 크기가 클수록` 알고리즘의 효율에 따라 실행 시간의 차이 발생

* 공간적 효율성
    - 얼마나 많은 메모리 공간을 요하는가?
* 시간적 효율성
    - 얼마나 많은 시간을 요하는가?
    
* 복잡도가 높을수록 효율성 저하

### 시간(또는 공간) 복잡도의 점근적 표기
* 입력 크기에 대한 함수로 표기 ( 함수는 다항식 )
* 단순한 함수로 표현하기 위해 `점근적 표기(Asymptotic Notation) 사용`
    - `점근적 표기`란? 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
    - `Big-Oh 표기`, `Big-Omega 표기`, `Theta 표기`

### 점근적 상한 
* Big-Oh 표기
    - 단순화된 함수 n^2에 `임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨` ( 단, c>0 )
    
### 점근적 하한
* Big-Omega 표기
    - f(n) = Omega(n^2)은 `n이 증가함에 따라 2n^2-7n+4가 cn^2보다 작을 수 없다` 라는 의미로 상수 c=1로 놓으면 됨
    - Omega-표기도 복잡도 다항식의 최고차항만 계수 없이 취함
    - `최소한 이만한 시간은 걸린다`라는 것을 의미

### 점근적 상한과 하한이 동일
* Theta 표기
    - Big-Oh 표기와 Big-Omega 표기가 같은 경우에 사용
    - f(n)은 n이 증가함에 따라 `n^2과 동일한 증가율을 가진다`라는 의미

### 자주 사용하는 O-표기
* `O(1)`: 상수 시간(Constant time)
* `O(logn)`: 로그(대수) 시간(Logarithmic time)
* `O(n)`: 선형 시간(Linear time)
* `O(nlogn)`: 로그 선형 시간(Log-linear time)
* `O(n^2)`: 제곱 시간(Quadratic time)
* `O(n^3)`: 세제곱 시간(Cubic time)
* `O(2^n)`: 지수 시간(Exponential time)

### 효율적 알고리즘의 필요성
- 10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음
- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 더 경제적

<br>

## 3. 비트 연산
### 비트 연산자
| 연산자 | 연산자의 기능 | 예시 |
|:---:|:---:|:---:|
| `&` | 비트단위로 AND 연산을 한다. | 예) num1 & num2 |
|  `|` | 비트단위로 OR 연산을 한다. | 예) num1 | num2 |
| `^` | 비트단위로 XOR 연산을 한다. (같으면 0 다르면 1) | 예) num1 ^ num2 |
| `~` | 단항 연산자로서 피연산자의 모든 비트를 반전시킨다. | 예) ~num |
| `<<` | 피연산자의 비트 열을 왼쪽으로 이동시킨다. | 예) num << 2 |
| `>>` | 피연산자의 비트 열을 오른쪽으로 이동시킨다. | 예) num >> 2 |
* 프로그램에서 비트 연산 적용 시  `연산 속도를 향상시키거나 메모리 절약 가능`    

* 1 << n
    - 2^n의 값을 가짐
    - 원소가 n개일 경우의 모든 부분집합의 수를 의미
    - Power set(모든 부분 집합)
        * 공집합과 자기 자신을 포함한 모든 부분집합
        * 각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨
* i & ( 1 << j )
    - 계산 결과는 `i의 j번째 비트가 1인지 아닌지를 의미`  

### 비트 연산 예제
#### 비트 연산1
특정 위치의 비트값을 확인하는 수식에 대한 예제
```
def BitPrint(i):
    for j in range(7, -1, -1):
        print('1' if (i & (1 << j)) else '0', end="")
        # print("%d" %((i >> j) & 1), end="")

for i in range(-5,6):
    print("%2d = " %i, end="") # 십진수 출력
    BitPrint(i) # 이진수 출력
    print()
```

### 엔디안(Endianness)
컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하여 HW 아키텍처마다 다름

* 빅 엔디안(Big-endian)
    - 보통 큰 단위가 앞에 나옴
    - 네트워크
* 리틀 엔디안(Little-endian)
    - 작은 단위가 앞에 나옴
    - 대다수 데스크탑 컴퓨터

#### 비트 연산2
자신의 컴퓨터가 어떤 엔디안 방식인지 확인하는 코드
```
n = 0x00111111

if n & 0x11:
    print("little endian") # 11 11 11 00
else:
    print("big endian") # 00 11 11 11
```

<br>

## 4. 진수
### 진법 변환
* 10진수를 `타 진수로 변환`하는 방법
    - 원하는 타진법의 수로 나눈 뒤 나머리를 거꾸로 읽음
* 타 진수를 `10진수로 변환`하는 방법
    - 각 자릿값을 행당 진수의 값을 곱해서 구함
* 2진수, 8진수, 16진수간 변환
    - 16진수 표현이 2진수 4비트 형태로 표현 - 2진수 네 자리씩 묶어서 16진수로 표현
    - 8진수는 2진수 세 자리씩 묶어서 표현
    - 8진수와 16진수의 각 자리들을 세 자리와 네 자리로 풀어서 나열하여 2진수로 변환

### 음의 정수 표현
* 1의 보수
    - 부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환
* 2의 보수
    - 1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함

<br>

## 5. 실수
### 2진 실수 
* 2진 실수를 10진수로 변환하는 방법
    - 각 자릿값을 2진수의 값을 곱해서 구함

### 부동 소수점 표기법
소수점의 위치를 고정시켜 표현하는 방식으로, 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현  
  
컴퓨터에서의 실수 저장 형식에는 `단정도 실수(32비트)`, `배정도 실수(64비트)` 등이 있다.  
* 단정도 실수(32비트)
    - 부호, 가수부, 지수부로 구분하여 저장  
    - `부호 1비트, 지수 8비트, 가수 23비트`
    - 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
    - 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것
    
* 배정도 실수(64비트)
    - `부호 1비트, 지수 11비트, 가수 52비트`

파이썬에서 실수 표현은 단정도 실수는 사용하지 않고 8바이트 크기의 float 타입 배정도 실수로만 처리한다.  
<br>

#### 단정도 실수의 가수 부분을 만드는 방법

`예) 1001.0011`

* 정수부의 첫 번째 자리가 1이 되도록 소소점 오른쪽으로 이동
* 소수점 이하를 23비트로 만듦
* 소수점 이하만을 가수 부분에 저장
* 지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소

#### 단정도 실수의 지수 부분을 만드는 방법
* 지수부는 숫자로 0-255(8비트)까지 나타낼 수 있지만, `음수 값을 나타낼 수 있어야 하기 때문에 익세스(Excess) 표현법 사용`
    - `익세스(Excess)표현법` : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법
    - 실제 지수 + 127

### 유효 숫자
이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장하는데, 근사값으로 저장될 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.  

#### 실수 자료형의 유효 자릿수
* 32비트 실수형 유효자릿수(십진수) => 6
* 64비트 실수형 유효자릿수(십진수) => 15
<br>

## Reference & Additional Resources
> SW Expert Academy
