# 완전 검색
*written by sohyeon*🍀

<br>

## 1. 완전 검색 기법
### 베이비진(Baby-Gin)
```
1. 0~9 사이의 숫자 카드에서 `임의의 카드 6장 뽑음`
1-1. 3장의 카드가 연속적인 번호를 갖는 경우 런(Run)
1-2. 3장의 카드가 동일한 번호를 갖는 경우 트리플릿(Triplete)
2. 6장의 카드가 Run과 Triplet로만 구성된 경우를 Baby-Gin으로 부름
```

### 완전 검색
* 문제의 해를 얻기 위해 `가능한 모든 경우들을 나열해 보고 확인`하는 기법
    - 고지식한 방법(Brute-force), 생성 및 테스트(Generate and test)
    - Brute-force의 force의 의미는 사람보다는 컴퓨터의 힘을 의미
* 문제를 해결하기 위한 간단하고 쉬운 접근법
    - 상대적으로 빠른 시간에 문제 해결(알고리즘 설계) 가능
* 대부분의 문제에 적용 가능
* 문제에 포함된 자료(요소, 인스턴스)의 크기가 작을 경우 유용

### 고지식한 검색 (순차 검색, Sequential Search)
자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행

#### 정렬되지 않는 자료의 예제
```
def sequentialSearch(a,n,key):
    i = 0
    while i < n and a[i] != key:
        i = i + 1

    if i < n: 
        return i # 성공하면 키 값의 인덱스 값 반환
    else: 
        return -1 # 실패하면 -1 반환
```

* 순차 검색에서 `리스트에 키 값이 존재하지 않는다는 것`을 확신하기 위해서는 `모든 자료들에 대해 키 값과 비교 작업 수행`

### 완전 검색으로 시작하기
* 문제 해결을 위한 가장 단순한 방법이기 때문에 `문제의 크기가 커지면 시간 복잡도가 매우 크게 증가`
* 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적음
    - 완전 검색을 통해 `입력의 크기를 작게 해서 빠르게 답을 구하는 알고리즘 설계`
* 그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾음
* 주어진 문제를 해결하는 방법
    - 완전 검색으로 접근하여 해답 도출
    - 성능 개설을 위해 다른 알고리즘 사용
    - 해답 확인

#### ex) 완전 검색을 통한 Baby-gin 접근
```
1. 고려할 수 있는 모든 경우의 수 생성하기
    > 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
2. 해답 테스트하기
    > 앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함
    > 단순히 순열 생성 시 중복된 작업 수행
    > 중복을 제거할 수 있다면 계산 시간 단축 가능
```

<br>

## 2. 조합적 문제

### 완전 검색
* 많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 검색
* 순열(Permutation), 조합(Combination), 부분집합(Subset)과 같은 조합적 문제(Combinatorial Problems)와 관련
* 조합적 문제에 대한 `고지식한 방법(Brute-force)`

### 순열(Permutation)
서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것  
* 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현 : `nPr`
* nPr은 다음과 같은 식이 성립 : `nPr = n * (n-1) * (n-2) * ... * (n-r+1)`

#### 순열과 관련된 다수의 알고리즘 문제들
* 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련됨
    - 순회 외판원 문제(Traveling Salesman Problem)
        * 여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어짐
        * 출발 도시에서 시작해서 다른 모든 도시들을 단 한 번만 방문하고 출발
        * 방문할 도시들을 순서대로 나열하면 하나의 경로가 됨

#### ex) {1, 2, 3} 로 순열 생성
동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop을 이용
```
for i in range(1,4):
    for j in range(1,4):
        if j != i: # 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 for loop를 이용해서 구현
            for k in range(1,4):
                if k != i and k != j:
                    print(i, j, k)
```

* Baby-Gin을 판별하는 프로그램은 여섯 개의 for loop를 중첩해서 `모든 순열을 만들어 냄`
* 일반적으로 `재귀 호출을 이용`해서 필요한 횟수만큼 반복을 수행하면서 수열 생성

### 순열을 만드는 방법
* 사전식 순서
    - 요소들이 오름차순으로 나열된 형태가 시작하는 하나의 순열
* 최소 변경을 통한 방법
    - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성
    - {1, 2, 3} 순열에서 1과 3을 교환해서 {3, 2, 1} 순열을 만듦

#### 최소한의 변경(Minimum-change requirement)을 통해 순열을 생성하는 방법
* Johnson-Trotter 알고리즘
    - 각 선들 => 네 개의 요소에 대응되고 점이 표시괸 선이 교환되는 요소
* 1950년대의 교회의 종소리 패턴하고 유사
```
-------------------------------------------------
  |     |     |   |     |     |   |     |     |  
-------------------------------------------------
    |       |       |       |       |       |  
-------------------------------------------------
      |   |     |     |   |     |     |   |     
-------------------------------------------------
```

#### 두 원소의 교환을 통해 생성
* N개의 요소가 있을 때 N번의 선택으로 순열 생성
* 순열이 생성되는 모든 과정을 그리면 `트리 구조`를 가짐
    * 요소의 수가 네 개로 루트는 자식이 네 개이고 트리의 높이가 1인 내부노드들은 자식이 세 개가 되는 구조의 트리가 됨
    * 네 번의 선택을 하기 때문에 트리의 높이는 4가 됨
    * 트리를 순회하는 것과 같이 재귀 호출을 통해 순열을 생성
    * 트리의 단말에 도착하게 되면 하나의 순열 생성

#### ex) 재귀 호출을 통한 순열 생성 예제
```
# a[]: 데이터가 저장된 리스트
# n: 원소의 개수, k: 현재까지 선택된 원소의 수

def perm(n, k):
    if k == n:   # 하나의 순열이 생성됨
        print(a) # 원하는 작업 수행
    else:
        for i in range(k, n):
            a[k], a[i] = a[i], a[k] # 교환을 통한 선택
            perm(n, k+1)            # 재귀호출
            a[k], a[i] = a[i], a[k] # 이전 상태로 복귀
```

#### ex) 파이썬의 라이브러리를 활용한 순열
```
import itertools

mylist = [1,2,3]
result = itertools.permutations(mylist) # (mylist, 3), r 생략시 기본값 리스트 크기

print(list(result))

# 결과값: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]

```

#### ex) 파이썬의 라이브러리를 활용한 중복순열
```
import itertools

mylist = [1,2,3]
result = itertools.product(mylist, repeat=3)

print(list(result))

# 결과값: [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 3, 1), (1, 3, 2), (1, 3, 3), (2, 1, 1), (2, 1, 2), (2, 1, 3), (2, 2, 1), (2, 2, 2), (2, 2, 3), (2, 3, 1), (2, 3, 2), (2, 3, 3), (3, 1, 1), (3, 1, 2), (3, 1, 3), (3, 2, 1), (3, 2, 2), (3, 2, 3), (3, 3, 1), (3, 3, 2), (3, 3, 3)]

```

### 부분집합
* 집합에 포함된 원소들을 선택하는 것
* 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것
* ex) 배낭 짐싸기(Knapsack problem)
    * 배낭과 물건들의 집합이 주어지며, 배낭은 무게가 있고 아이템들은 각가 무게와 가치가 있음
    * 배낭에 담는 무게의 총합 < 배낭의 무게
    * 물건의 총합이 배낭의 무게를 초과하지 않으면서 가치의 합이 최대가 되는 물건들을 선택하는 문제
* N개의 원소를 포함한 집합
    - 자기 자신과 공집합 포함한 `모든 부분집합(Power set)의 개수는 2^n개`

#### ex) 단순하게 모든 부분 집합을 생성하는 예제
```
arr = [2,3,4,5] # 실제 집합
bit = [0] * len(arr)

for i in range(2):
    bit[0] = i                 # 0번째 원소
    for j in range(2):
        bit[1] = j             # 1번째 원소
        for k in range(2):
            bit[2] = k         # 2번째 원소
            for l in range(2):
                bit[3] = l     # 3번째 원소
                print([arr[x] for x in range(len(bit)) if bit[x]])  # 생성된 부분집합을 출력
```

### 바이너리 카운팅(Binary Counting)
* 비트표현을 이용해서 부분집합을 생성하는 방법
* 원소 수에 해당하는 N개의 비트 열을 이용
* i 번째 비트 값이 1이면 i 번째 원소가 포함되었음을 의미 ( i 는 인덱스 )

#### ex) 바이너리 카운팅을 통한 부분집합 생성하는 예제
```
arr = [2,3,4,5]
n = len(arr) # n : 원소의 개수

for i in range(1<<n):   # 1<<n : 부분 집합의 개수
    for j in range(n):  # 원소의 수만큼 비트를 비교함
        if i & (1<<j):  # i의 j번째 비트가 1이면 j번째 원소 출력  
            print(arr[j], end=",")
        print()
```

```
# 리스트의 함축을 이용한 코드

arr = [2,3,4,5]

for i in range(1<<len(arr)):
    print([arr[j] for j in range(len(arr)) if i & (1<<j)])
```

### 조합
* 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것
* 조합의 수식
    - `nCr = n!/[(n-r)!r!]`
    - `nC0 = 1, nCn = 1`
    - `nCr = nC(n-r)`
    - `nCr = (n-1)C(r-1) + (n-1)Cr`
* 재귀적 정의의 표현
    - 5C3 = 4C2 + 4C3
    - 다섯 개에서 세 개를 선택하는 모든 경우
        * 5가 포함되는 경우 & 5가 포함되지 않는 경우
        * `5C3`은 5를 포함한 `4C2의 경우의 수`와 5를 제외한 `4C3의 경우의 수를 합`한 것과 같음

#### ex) 재귀 호출을 이용한 조합 생성 알고리즘
```
# an[] : n개의 원소를 가지고 있는 리스트
# tr[] : 조합이 임시 저장될 r개의 크기의 리스트

def comb(n, r):
    if r == 0: print(tr)
    elif n < r: return
    else:
        tr[r-1] = an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
```

#### ex) 파이썬의 라이브러리를 활용한 조합
```
import itertools

mylist = [1,2,3]
result = itertools.combinations(mylist, r=2) # r 생략불가
print(list(result))
```

#### ex) 파이썬의 라이브러리를 활용한 중복조합
```
import itertools

mylist = [1,2,3]
result = itertools.combinations_with_replacement(mylist, r=2) # r 생략불가
print(list(result))
```

<br>

## Reference & Additional Resources
> SW Expert Academy
