# 탐욕 알고리즘
*written by sohyeon*🍀

<br>

## 1. 탐욕 알고리즘
### 탐욕(그리디) 알고리즘
* `최적화 문제`를 해결하는 알고리즘
    - 탐욕 알고리즘은 `최적해`를 구하는 데 사용되는 근시안적인 방법
* 머리 속에 떠오르는 생각을 검증 없이 바로 구현할 경우 Greedy 접근이 됨
* 여러 경우 중 하나 선택 => 선택 시 마다 최적이라고 생각되는 것을 선택 =>  `최종적인 해답에 도달`
    - 한번 선택된 것은 번복하지 않음
        * 대부분의 탐욕 알고리즘들은 `단순하며, 제한적인 문제들에 적용`
    - 각 선택의 시점에서 이루어지는 `결정은 지역적으로 최적`
        * 선택들을 계속 수집하여 최종적 해답을 만들었다고 하여 최적이라는 보장은 없음

### 탐욕 알고리즘의 수행 과정
* 1. 해 선택
    * 현재 상태에서 부분 문제의 최적해를 구한 뒤, 부분 해 집합(Solution Set)에 추가
    * 하나의 선택이 이루어지면 새로운 부분 문제 발생
* 2. 실행 가능성 검사 실시
    * 새로운 부분 해 집합의 `실행가능 여부 확인`
    * 문제의 `제약 조건 위반을 검사`
* 3. 해 검사
    * 새로운 부분 해 집합이 문제의 해가 되는지 확인
    * 전체 문제의 해가 완성되지 않았다면 `1의 해 선택부터 다시 시작`
    
<br>

## 2. 동전 거스름돈 문제
### 동전 거스름돈 문제를 탐욕 기법을 적용해서 풀어보기
탐욕 기법을 적용한 거스름돈 줄이기
* 1. 해 선택 단계
    - 가장 좋은 해 선택
    - 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어들므로  `현재 고를 수 있는 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가`
* 2. 실행 가능성 검사
    - 거스름돈이 손님에게 내드려야 할 `액수를 초과하는지 확인`
    - 초과할 경우 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전 추가
* 3. 해 검사
    - `거스름돈 문제의 해` = 손님에게 내드려야 하는 거스름돈의 액수
    - 거스름돈을 확인해서 액수에 모자라면 다시 1로 돌아가서 거스름돈에 추가할 동전 선택

* 최소 동전 개수로 800원을 거슬러 주는 방법
    - 0원이 되도록 트리의 단말 노드까지 가는 `간선의 수가 최소`인 경우

<br>

## 3. 배낭 문제
* 도둑은 부자들의 값진 물건들을 훔치기 위해 보관 창고에 침입
* 도둑은 훔친 물건을 배낭에 담아올 계획
    - 배낭은 담을 수 있는 물건의 총 무게가 정해져 있음
* 창고에는 여러 개(n개)의 물건들이 있고 각각의 물건에는 무게와 값이 정해져 있음
* 경비원들에게 발각되기 전에 배낭의 무게를 초과하지 않으면서, 값의 총합이 최대가 되도록 물건들 선택해서 담기

### Knapsack 문제의 정형적 정의
* S = {item1, item2, ... , itemN}, 물건들의 집합
* w = item의 무게, P = item의 값(가치)
* W = 배낭이 수용가능한 총 무게
* 문제 정의
    - 물건들 무게의 합이 배낭무게를 초과하지 않으면서 물건들 가치의 합이 최대가 되는 집합 S의 부분집합을 결정하는 문제
    
### Knapsack 문제 유형
* 0-1 Knapsack
    - 배낭에 물건을 `통째로 담아야` 하는 문제
    - 물건을 `쪼갤 수 없는 경우`
* Fractional Knapsack
    - 물건을 `부분적으로 담는` 것이 허용되는 문제
    - 물건을 `쪼갤 수 있는 경우`
    - 물건을 쪼개는 만큼 가치를 나눠야 한다

### 0-1 Knapsack에 대한 완전 검색 방법
* 완전 검색으로 물건들의 집합 S에 대한 `모든 부분집합을 구함`
* 부분집합의 `총 무게가 배낭 무게 W를 초과하는 집합들은 버리고`, 나머지 집합에서 총 값이 가장 큰 집합 선택
* 물건의 개수가 증가하면 `시간 복잡도가 지수적으로 증가`
    - 원소의 수 n인 집합의 부분합의 수:  2^n

#### 0-1 Knapsack에 대한 탐욕적 방법
* 값이 비싼 물건부터 채움
* 무게가 가벼운 물건부터 채움
* 무게 당 값이 높은 순서로 물건 채움
    - 탐욕적 방법으로 최적해 구할 수 없음
    - 완전검색을 통해 최적해를 구해야 함

#### Fractional Knapsack 문제
* 물건의 일부를 잘라서 담을 수 있는 경우
    - 탐욕적 방법으로 최적해를 구할 수 있음
    - `최적해`는 이상적으로 구할 수 있는 `최대 가치`

<br>

## 4. 활동 선택 문제
### 회의실 배정 문제
* 이번 주 금요일에 `사용 가능한 회의실은 하나만 존재`하고 다수의 회의가 신청된 상태
* 회의는 시작 시간과 종료 시간 존재
* 회의 시간이 겹치는 회의들은 `동시에 개최 불가능`
  
`가능한 많은 회의가 열리기 위해서 회의들을 어떻게 배정해야 할까요?`

#### 회의실 배정 문제 - 활동 선택 문제
* 시작 시간과 종료 시간이 있는 n개의 활동들의 집합
* A = {a1, a2, ... , an}, 1 <= i <= n에서 서로 겹치지 않는 최대 개수의 활동들의 집합을 구하는 문제
    - 회의 시간이 서로 겹치지 않는 `최대 개수의 활동들의 집합`을 구하는 문제
* 양립 가능한 활동들의 크기가 최대가 되는 S(0, n+1)의 부분집합을 선택하는 문제
    - 종료 시간 순으로 활동들 정렬
    - S(0, n+1)는 `a0의 종료 시간`부터 `a(n+1)의 시작 시간` 사이에 포함된 활동들
    
### 탐욕 기법의 적용
* 공집합이 아닌 문제 S(i, j)가 있고 S(i, j)에 속한 활동 `a(m)은 종료 시간이 가장 빠른 활동`
    - 문제 S(i, j)에서 종료 시간이 가장 빠른 활동 a(m)을 선택
    - S(i, m)은 공집합이므로, a(m)을 선택하면 공집합이 아닌 하위 문제 S(m, j)가 남음

#### ex) 탐욕 기법을 적용한 반복 알고리즘
```
A : 정렬된 활동(회의)들의 집합
S : 선택된 활동(회의)들의 집합
s(i) : 시작 시간, f(i) : 종료 시간, 1<=i<=n # 1번

S = {a1} # 2번
j = 1
for i in range(2, n+1):
    if s(i) >= f(j): # 3번
        S = S U {a(i)}
        j = i
```
1. 종료 시간이 빠른 순서로 활동들 정렬
2. 첫 번째 활동(a1)을 선택하고 해집합에 포함
3. 선택한 황동(a1)의 종료 시간보다 빠른 시작 시간을 가지는 활동을 모두 제거
4. 남은 활동들에 대해 앞의 과정 반복

#### ex) 재귀 알고리즘
```
A : 정렬된 활동(회의)들의 집합
S : 선택된 활동(회의)들의 집합
s(i) : 시작 시간, f(i) : 종료 시간, 1<=i<=n

Recursive_Selection(i, j):
    m = i+1
    
    while m <= j and s(m) < f(i): # 종료 시간이 가장 빠른 활동 선택
        m = m+1
        
    if m <= j:  return {a(m)} U Recursive_Selection(m, j)
    else:   return {} # 공집합
```

### 탐욕 알고리즘이 최적해를 구한다는 것에 대한 증명
* 탐욕적 선택 속성(Greedy choice property)
    - 탐욕적 선택은 최적해로 갈 수 있음
        * 탐욕적 선택은 항상 안전하다는 것을 보여야 함
* 최적 부분 구조(Optimal substructure property)
    - 최적화 문제를 정형화
        * 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남음
    - `원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해` 임을 증명
    
### 탐욕 기법과 동적 계획법의 비교
| 탐욕 기법 | 동적 계획법 | 
|:---:|:---:|
| 매 단계에서, 가장 좋아 보이는 것을 빠르게 선택한다<br>=> 지역 최적 선택(local optimal choice) | 매 단계의 선택은 해결한 하위 문제의 해를 기반으로 한다 | 
| 하위 문제를 풀기 전에 (탐욕적)선택이 먼저 이루어진다 | 하위 문제가 우선 해결된다 | 
| Top-down 방식 | Bottom-up 방식 |
| 일반적으로 빠르고 간결하다 | 좀 더 느리고, 복잡하다 |

<br>

## 5. Baby-Gin 다시보기
### 탐욕 기법을 통한 Baby-Gin 문제 해결
* 6개의 숫자는 6자리의 정수 값으로 입력되며 카운트 리스트에 저장
    - 카운트 리스트는 0에서 9까지의 숫자의 빈도수를 저장하는 리스트
* Counts 리스트의 각 원소를 체크하여 Run과 Triplet 및 Baby-Gin 여부 판단
* 탐욕 알고리즘 방법 적용
    - 카운트 리스트에서 Run과 Triplet 중에 가능한 것을 조사
    * 조사에 사용한 데이터는 삭제
    * 남은 데이터를 다시 Run과 Triplet 중에 가능한지를 조사
    
<br>

## Reference & Additional Resources
> SW Expert Academy
