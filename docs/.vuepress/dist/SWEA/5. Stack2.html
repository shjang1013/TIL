<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Stack2 | Today Sohyeon Learned💡</title>
    <meta name="description" content="Personal Wiki (Today I Learned)">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="icon" href="/TIL/images/logo-144.png">
  <link rel="manifest" href="/TIL/manifest.json">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.b1e872f3.css" as="style"><link rel="preload" href="/TIL/assets/js/app.6651a9c9.js" as="script"><link rel="preload" href="/TIL/assets/js/2.73ccfab7.js" as="script"><link rel="preload" href="/TIL/assets/js/13.95346731.js" as="script"><link rel="preload" href="/TIL/assets/js/4.58ecc0e6.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.343cefc1.js"><link rel="prefetch" href="/TIL/assets/js/11.deb81709.js"><link rel="prefetch" href="/TIL/assets/js/12.1f13027a.js"><link rel="prefetch" href="/TIL/assets/js/14.5d675fae.js"><link rel="prefetch" href="/TIL/assets/js/15.4147562d.js"><link rel="prefetch" href="/TIL/assets/js/16.3c477810.js"><link rel="prefetch" href="/TIL/assets/js/17.144d3a51.js"><link rel="prefetch" href="/TIL/assets/js/18.9c371c9c.js"><link rel="prefetch" href="/TIL/assets/js/19.78c0de15.js"><link rel="prefetch" href="/TIL/assets/js/3.043b2d53.js"><link rel="prefetch" href="/TIL/assets/js/5.6798762f.js"><link rel="prefetch" href="/TIL/assets/js/6.db9e3bfb.js"><link rel="prefetch" href="/TIL/assets/js/7.6e4a79f2.js"><link rel="prefetch" href="/TIL/assets/js/8.01fc74fe.js"><link rel="prefetch" href="/TIL/assets/js/9.3f1d58cc.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.b1e872f3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today Sohyeon Learned💡</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>🎯 목표</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>📒 SWEA</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/SWEA/1. List1.html" class="sidebar-link">List1</a></li><li><a href="/TIL/SWEA/10. 완전 검색.html" class="sidebar-link">완전 검색</a></li><li><a href="/TIL/SWEA/2. List2.html" class="sidebar-link">List2</a></li><li><a href="/TIL/SWEA/3. String.html" class="sidebar-link">String</a></li><li><a href="/TIL/SWEA/4. Stack1.html" class="sidebar-link">Stack1</a></li><li><a href="/TIL/SWEA/5. Stack2.html" class="active sidebar-link">Stack2</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/SWEA/5. Stack2.html#_1-계산기에서-stack의-활용" class="sidebar-link">1. 계산기에서 Stack의 활용</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/5. Stack2.html#_2-백트래킹" class="sidebar-link">2. 백트래킹</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/5. Stack2.html#_3-분할정복" class="sidebar-link">3. 분할정복</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/5. Stack2.html#reference-additional-resources" class="sidebar-link">Reference &amp; Additional Resources</a></li></ul></li><li><a href="/TIL/SWEA/6. Queue.html" class="sidebar-link">Queue</a></li><li><a href="/TIL/SWEA/7. Linked List.html" class="sidebar-link">Linked List</a></li><li><a href="/TIL/SWEA/8. Tree.html" class="sidebar-link">Tree</a></li><li><a href="/TIL/SWEA/9. 시작하기.html" class="sidebar-link">시작하기</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="stack2"><a href="#stack2" class="header-anchor">#</a> Stack2</h1> <p><em>written by sohyeon</em>🍀</p> <br> <h2 id="_1-계산기에서-stack의-활용"><a href="#_1-계산기에서-stack의-활용" class="header-anchor">#</a> 1. 계산기에서 Stack의 활용</h2> <h3 id="우선순위"><a href="#우선순위" class="header-anchor">#</a> 우선순위</h3> <table><thead><tr><th style="text-align:center;">토큰</th> <th style="text-align:center;">ISP(In-Stack Priority)</th> <th style="text-align:center;">ICP(In-Coming Priority)</th></tr></thead> <tbody><tr><td style="text-align:center;"><code>)</code></td> <td style="text-align:center;">-</td> <td style="text-align:center;">-</td></tr> <tr><td style="text-align:center;"><code>*, /</code></td> <td style="text-align:center;">2</td> <td style="text-align:center;">2</td></tr> <tr><td style="text-align:center;"><code>+, -</code></td> <td style="text-align:center;">1</td> <td style="text-align:center;">1</td></tr> <tr><td style="text-align:center;"><code>(</code></td> <td style="text-align:center;">0 (우선순위가 가장 낮음)</td> <td style="text-align:center;">3 (우선순위가 가장 높음)</td></tr></tbody></table> <h3 id="문자열-수식-계산의-일반적-방법"><a href="#문자열-수식-계산의-일반적-방법" class="header-anchor">#</a> 문자열 수식 계산의 일반적 방법</h3> <div class="language- extra-class"><pre class="language-text"><code>Step1 : 중위표기법의 수식을 후위표기법으로 변경
    =&gt; 스택 이용
    =&gt; 중위표기법(infix notation) : 연산자를 피연산자의 가운데 표기하는 방법
Step2 : 후위표기법의 수식을 스택을 이용하여 계산
    =&gt; 후위표기법(postfix notation) : 연산자를 피연산자 뒤에 표기하는 방법
</code></pre></div><h3 id="step1-중위-표기-식을-후위-표기-식으로-변환-1"><a href="#step1-중위-표기-식을-후위-표기-식으로-변환-1" class="header-anchor">#</a> Step1. 중위 표기 식을 후위 표기 식으로 변환 1</h3> <div class="language- extra-class"><pre class="language-text"><code>ex) A*B-C/D 변환 방법
1. 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
    =&gt; ((A*B)-(C/D))
2. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
    =&gt; ((A B)*(C D)/)-
3. 괄호 제거
    =&gt; AB*CD/-
</code></pre></div><h3 id="step1-중위-표기-식을-후위-표기-식으로-변환-2-스택-이용"><a href="#step1-중위-표기-식을-후위-표기-식으로-변환-2-스택-이용" class="header-anchor">#</a> Step1. 중위 표기 식을 후위 표기 식으로 변환 2 (스택 이용)</h3> <div class="language- extra-class"><pre class="language-text"><code>1. 입력 받은 중위표기식에서 토큰을 읽음
2. 토큰이 피연산자이면 토큰을 출력
3. 토큰이 연산자(괄호 포함)일 경우
    =&gt; top과 비교했을 경우 토큰이 우선순위가 높으면 -&gt; 스택에 push
    =&gt; top과 비교했을 경우 토큰이 우선순위가 안 높으면 -&gt; 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push
    =&gt; 만약 top에 연산자가 없으면 -&gt; push
4. 토큰이 오른쪽 괄호 ')'일 경우
    =&gt; 스택 top에 왼쪽 괄호 '('가 올 때까지 스택에 pop 연산을 수행
    =&gt; pop한 연산자를 출력
    =&gt; 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않음
5. 중위표기식에 더 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1부터 반복
6. 스택에 남아 있는 연산자를 모두 pop하여 출력
    =&gt; 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮음
</code></pre></div><h3 id="step2-후위-표기법의-수식을-스택을-이용하여-계산"><a href="#step2-후위-표기법의-수식을-스택을-이용하여-계산" class="header-anchor">#</a> Step2. 후위 표기법의 수식을 스택을 이용하여 계산</h3> <div class="language- extra-class"><pre class="language-text"><code>1. 피연산자를 만나면 스택에 push함
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push함
3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력

💡계산 시 주의사항!
- 후위표기식을 계산 시, 피연산자를 스택에 쌓아 계산!
</code></pre></div><h3 id="문자열로-된-수식을-계산-시"><a href="#문자열로-된-수식을-계산-시" class="header-anchor">#</a> 문자열로 된 수식을 계산 시</h3> <ul><li>스택을 두번 사용해서 처리했던 연산을 파이썬에서 제공하는 <code>eval() 내장 함수</code>로 계산할 수 있음</li></ul> <h4 id="eval-수식"><a href="#eval-수식" class="header-anchor">#</a> eval(수식)</h4> <div class="language- extra-class"><pre class="language-text"><code>- 문자열로 된 수식을 계산함
- Evalution = &quot;값을 구함&quot;이란 뜻
- 올바른 수식이 아닌 경우 SyntaxError 예외가 발생함
- eval(&quot;6+5*(2-8)/2&quot;) 는 문자열로 된 수식의 계산결과를 반환함
</code></pre></div><br> <h2 id="_2-백트래킹"><a href="#_2-백트래킹" class="header-anchor">#</a> 2. 백트래킹</h2> <h3 id="백트래킹-backtracking-이란"><a href="#백트래킹-backtracking-이란" class="header-anchor">#</a> 백트래킹(Backtracking)이란?</h3> <p>해를 찾는 도중에 '막히면', (즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 기법<br>
예를 들어, <code>최적화(Optimization)문제, 결정(Decision)문제</code> 등이 있다.</p> <h3 id="결정-decision-문제"><a href="#결정-decision-문제" class="header-anchor">#</a> 결정(Decision)문제</h3> <p>문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제</p> <ul><li>미로 찾기</li> <li>n-Queen 문제</li> <li>Map coloring</li> <li>부분 집합의 합(Subset Sum) 문제 등</li></ul> <h4 id="ex-백트래킹-기법-활용-미로-찾기"><a href="#ex-백트래킹-기법-활용-미로-찾기" class="header-anchor">#</a> ex) 백트래킹 기법 활용 - 미로 찾기</h4> <div class="language- extra-class"><pre class="language-text"><code>1. 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제
2. 이동할 수 있는 방향은 4방향으로 제한
    - 스택을 이용하여 지나온 경로를 역으로 되돌아 감
    - 스택을 이용하여 다시 경로를 찾기
</code></pre></div><h3 id="백트래킹과-깊이-우선-탐색의-차이"><a href="#백트래킹과-깊이-우선-탐색의-차이" class="header-anchor">#</a> 백트래킹과 깊이 우선 탐색의 차이</h3> <ul><li><p><code>백트래킹</code></p> <ul><li>어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 <code>시도의 횟수를 줄임</code></li> <li>가지치기(Prunning)</li> <li>불필요한 경로의 조기 차단</li> <li>N!가지의 경우의 수를 가진 문제에 대해 백트레킹에 가하면 일반적으로  <code>경우의 수가 줄어들지만</code> 이 역시 최악의 경우에는 여전히 지수함수 시간(Exponential Time)을 요하므로 처리 불가능</li></ul></li> <li><p><code>깊이 우선 탐색</code></p> <ul><li>모든 경로를 추적</li> <li>N!가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 <code>처리 불가능한 문제</code></li> <li>모든 후보를 검사</li></ul></li></ul> <h3 id="백트래킹-기법"><a href="#백트래킹-기법" class="header-anchor">#</a> 백트래킹 기법</h3> <ul><li>어떤 노드의 유망성을 점검한 후에 유망(Promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(Backtracking) 다음 자식 노드로 감</li> <li>어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 함</li> <li>반대로 <code>해답의 가능성이 있으면 유망하다</code>고 함</li> <li>가지치기(Prunnning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음</li></ul> <h3 id="백트래킹을-이용한-알고리즘의-절차"><a href="#백트래킹을-이용한-알고리즘의-절차" class="header-anchor">#</a> 백트래킹을 이용한 알고리즘의 절차</h3> <div class="language- extra-class"><pre class="language-text"><code>1. 상태 공간 Tree의 깊이 우선 검색을 실시
2. 각 노드가 유망한지를 점검
3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속
</code></pre></div><h4 id="ex-n-queen"><a href="#ex-n-queen" class="header-anchor">#</a> ex) N-Queen</h4> <p>n*n의 정사각형 안에 n개의 queen을 배치하는 문제로, 모든 queen은 자신의 <code>일직선 상 및 대각선 상</code>에 아무 것도 놓이지 않아야 함</p> <div class="language- extra-class"><pre class="language-text"><code># 백트래킹을 사용한 N Queen 문제를 풀기 위한 파이썬 프로그램
def nqueen(arr, n):
    global count

    if len(arr) == n: # 정답 배열(arr)의 길이가 n과 같아지면, count 증가
        count += 1
        return 0
    candidate = list(range(n)) # 0부터 n-1까지를 후보 배열로 만든다.
    
    for i in range(len(arr)):
        # 같은 열에 있는 지 확인
        if arr[i] in candidate: 
            candidate.remove(arr[i]) # 같은 열에 있다면 후보에서 제외
        distance = len(arr) - i
        
        # 같은 대각성 상(+)에 있는 지 확인
        if arr[i] + distance in candidate: 
            candidate.remove(arr[i] + distance) # 같은 대각선 상에 있다면 후보에서 제외
        # 같은 대각선 상(-)에 있는 지 확인
        if arr[i] - distance in candidate: 
            candidate.remove(arr[i] - distance) # 같은 대각선 상에 있다면 후보에서 제외

    if candidate != []:
        for i in candidate:
            arr.append(i) # 후보의 요소를 정답 배열의 i+1로 추가
            nqueen(arr, n) # 재귀적으로 다음 행도 확인
    else:
        return 0
        
count = 0
num = int(input())
for i in range(num): # 첫 행의 경우의 수
nqueen([i], num)
print(count)
</code></pre></div><h3 id="power-set"><a href="#power-set" class="header-anchor">#</a> Power Set</h3> <ul><li>어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합</li> <li>구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n이 나옴</li></ul> <h3 id="백트래킹-기법으로-power-set-구하기"><a href="#백트래킹-기법으로-power-set-구하기" class="header-anchor">#</a> 백트래킹 기법으로 Power Set 구하기</h3> <ul><li>일반적인 백트래킹 접근 방법 이용</li> <li>n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때, True또는 False 값을 가지는 항목들로 구성된 n개의 리스트를 만드는 방법 이용</li> <li><code>리스트의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값</code></li></ul> <h4 id="ex-power-set을-구하는-백트래킹-알고리즘-예제"><a href="#ex-power-set을-구하는-백트래킹-알고리즘-예제" class="header-anchor">#</a> ex) Power Set을 구하는 백트래킹 알고리즘 예제</h4> <div class="language- extra-class"><pre class="language-text"><code># a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위
def backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0] * MAXCANDIDATES

    if k == input:
        process_solution(a, k) # powerset을 출력

    else:
        k+=1
        ncandidates = construct_candidates(a, k, input, c) # 후보군 만들기 
        for i in range(ncandidates):
            a[k] = c[i] # 현재 단계에 후보군 하나를 넣음
            backtrack(a, k, input) # 다음단계를 진행하도록 k단계를 재귀호출 

# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위, c : 후보군을 저장할 배열
def construct_candidates(a, k, input, c):
    c[0] = True
    c[1] = False
    return 2      # 후보군 갯수

# 완성된 a 배열을 보고, 원소를 출력할지 확인해서 powerset을 출력
def process_solution(a, k):
    print(&quot;(&quot;, end='')
    for i in range(k+1):
        if a[i]:
            print(i, end=' ')
    print(&quot;)&quot;)

MAXCANDIDATES = 100
NMAX = 100
a = [0] * NMAX
backtrack(a, 0, 3)
</code></pre></div><h4 id="ex-순열을-구하는-백트래킹-알고리즘"><a href="#ex-순열을-구하는-백트래킹-알고리즘" class="header-anchor">#</a> ex) 순열을 구하는 백트래킹 알고리즘</h4> <div class="language- extra-class"><pre class="language-text"><code># a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위
def backtrack(a, k, input):
    global MAXCANDIDATES
    c = [0] * MAXCANDIDATES

    if k == input:
        for i in range(1, k+1):
            print(a[i], end=' ')
        print()    
    else:
        k+=1
        ncandidates = construct_candidates(a, k, input, c) # 후보군 만들기 
        for i in range(ncandidates):
            a[k] = c[i] # 현재 단계에 후보군 하나를 넣음
            backtrack(a, k, input) # 다음단계를 진행하도록 k단계를 재귀호출 


# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위, c : 후보군을 저장할 배열
def construct_candidates(a, k, input, c):
    in_perm = [False] * NMAX

    for i in range(1,k):
        in_perm[a[i]] = True

    ncandidates = 0

    for i in range(1, input+1):
        if in_perm[i] == False:
            c[ncandidates] = i
            ncandidates += 1

    return ncandidates
</code></pre></div><br> <h2 id="_3-분할정복"><a href="#_3-분할정복" class="header-anchor">#</a> 3. 분할정복</h2> <h3 id="분할-정복-알고리즘"><a href="#분할-정복-알고리즘" class="header-anchor">#</a> 분할 정복 알고리즘</h3> <ul><li>분할(Divide) : 해결할 문제를 <code>여러 개의 작은 부분</code>으로 나눔</li> <li>정복(Conquer) : 나눈 작은 문제를 <code>각각 해결</code></li> <li>통합(Combine) : (필요하다면) 해결된 <code>해답을 모음</code></li></ul> <h4 id="거듭-제곱-exponentiation-알고리즘-o-n"><a href="#거듭-제곱-exponentiation-알고리즘-o-n" class="header-anchor">#</a> 거듭 제곱(Exponentiation) 알고리즘 : O(n)</h4> <div class="language- extra-class"><pre class="language-text"><code>def Power(Base, Exponent):
    if Base == 0:   
        return 1
    result = 1 # Base^0은 1이므로
    for i in range(Exponent):
        result *= Base
    return result
</code></pre></div><h4 id="분할-정복-기반의-알고리즘-o-log2n"><a href="#분할-정복-기반의-알고리즘-o-log2n" class="header-anchor">#</a> 분할 정복 기반의 알고리즘 : O(log2n)</h4> <div class="language- extra-class"><pre class="language-text"><code>def Power(Base, Exponent):
    if Exponent == 0 or Base == 0:
        return 1
    if Exponent % 2 == 0:
        NewBase = Power(Base, Exponent/2)
        return NewBase * NewBase
    else:
        NewBase = Power(Base, (Exponent-1)/2)
        return (NewBase * NewBase) * Base
</code></pre></div><h3 id="퀵-정렬과-합병-정렬의-비교"><a href="#퀵-정렬과-합병-정렬의-비교" class="header-anchor">#</a> 퀵 정렬과 합병 정렬의 비교</h3> <table><thead><tr><th style="text-align:center;">정렬 비교</th> <th style="text-align:center;">합병 정렬</th> <th style="text-align:center;">퀵 정렬</th></tr></thead> <tbody><tr><td style="text-align:center;">공통점</td> <td style="text-align:center;">주어진 리스트를 두 개로 분할하고, 각각을 정렬</td> <td style="text-align:center;">(이하동문)</td></tr> <tr><td style="text-align:center;">차이점</td> <td style="text-align:center;">분할할 때, 단순하게 두 부분으로 나눔</td> <td style="text-align:center;">분할할 때, <code>기준 아이템(Pivot Item)</code>을 중심으로, 이보다 <code>작은 것은 왼편, 큰 것은 오른편</code>에 위치시킴</td></tr> <tr><td style="text-align:center;"></td> <td style="text-align:center;">각 부분 정렬이 끝난 후, <code>합병이란 후처리 작업이 필요함</code></td> <td style="text-align:center;">각 부분 정렬이 끝난 후, <code>후처리 작업이 필요로 하지 않음</code></td></tr></tbody></table> <h3 id="퀵-정렬-알고리즘"><a href="#퀵-정렬-알고리즘" class="header-anchor">#</a> 퀵 정렬 알고리즘</h3> <div class="language- extra-class"><pre class="language-text"><code># 주어진 리스트에서 피봇을 구하는 알고리즘
def partition(a, begin, end):
    pivot = (begin + end) // 2
    L = begin
    R = end

    while L &lt; R: # L과 R이 만나지 않을 경우
        while(a[L] &lt; a[pivot] and L &lt; R):
            L += 1
        while(a[R] &gt;= a[pivot] and L &lt; R):
            R -= 1
        if L &lt; R:
            if L == pivot:
                pivot = R
            a[L], a[R] = a[R], a[L]

    a[pivot], a[R] = a[R], a[pivot]
    return R

# 퀵 정렬 알고리즘
def quickSort(a, begin, end):
    if begin &lt; end:
        p = partition(a, begin, end)
        quickSort(a, begin, p-1)
        quickSort(a, p+1, end)
</code></pre></div><h4 id="퀵-정렬-수행-과정"><a href="#퀵-정렬-수행-과정" class="header-anchor">#</a> 퀵 정렬 수행 과정</h4> <div class="language- extra-class"><pre class="language-text"><code>ex) a = [68, 11, 29, 3, 15, 9, 32, 23]

1. 원소 2를 피봇으로 선택하고 퀵 정렬 시작하기
2. 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기
3. 피봇 15의 왼쪽 부분 집합에서 원소 10을 피봇으로 선택하여 퀵 정렬 수행하기 
4. 원소 16에 대한 오른쪽 부분 집합에 대해 퀵 정렬을 수행하기
5. 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기 
</code></pre></div><ul><li>퀵 정렬의 최악의 시간 복잡도는 <code>O(n^2)</code> ⇒ 합병정렬에 비해 좋지 못함</li> <li>퀵 정렬의 평균 복잡도는 <code>nlogn</code>이기 때문에 빠른(Quick) 정렬이라고 함</li></ul> <h3 id="퀵-정렬의-특성"><a href="#퀵-정렬의-특성" class="header-anchor">#</a> 퀵 정렬의 특성</h3> <table><thead><tr><th style="text-align:center;">알고리즘</th> <th style="text-align:center;">평균 수행 시간</th> <th style="text-align:center;">최악 수행 시간</th> <th style="text-align:center;">알고리즘 기법</th> <th style="text-align:center;">비고</th></tr></thead> <tbody><tr><td style="text-align:center;">퀵 정렬</td> <td style="text-align:center;">O(nlogn)</td> <td style="text-align:center;">O(n^2)</td> <td style="text-align:center;">분할 정복</td> <td style="text-align:center;">최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠름</td></tr></tbody></table> <br> <h2 id="reference-additional-resources"><a href="#reference-additional-resources" class="header-anchor">#</a> Reference &amp; Additional Resources</h2> <blockquote><p>SW Expert Academy</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">3/23/2020, 3:13:08 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/TIL/SWEA/4. Stack1.html" class="prev">
        Stack1
      </a></span> <span class="next"><a href="/TIL/SWEA/6. Queue.html">
        Queue
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/TIL/assets/js/app.6651a9c9.js" defer></script><script src="/TIL/assets/js/2.73ccfab7.js" defer></script><script src="/TIL/assets/js/13.95346731.js" defer></script><script src="/TIL/assets/js/4.58ecc0e6.js" defer></script>
  </body>
</html>
