(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{385:function(t,e,a){"use strict";a.r(e);var n=a(27),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"stack2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stack2"}},[t._v("#")]),t._v(" Stack2")]),t._v(" "),a("p",[a("em",[t._v("written by sohyeon")]),t._v("🍀")]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"_1-계산기에서-stack의-활용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-계산기에서-stack의-활용"}},[t._v("#")]),t._v(" 1. 계산기에서 Stack의 활용")]),t._v(" "),a("h3",{attrs:{id:"우선순위"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#우선순위"}},[t._v("#")]),t._v(" 우선순위")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("토큰")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("ISP(In-Stack Priority)")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("ICP(In-Coming Priority)")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("code",[t._v(")")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("-")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("code",[t._v("*, /")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("2")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("code",[t._v("+, -")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("1")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[a("code",[t._v("(")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("0 (우선순위가 가장 낮음)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("3 (우선순위가 가장 높음)")])])])]),t._v(" "),a("h3",{attrs:{id:"문자열-수식-계산의-일반적-방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#문자열-수식-계산의-일반적-방법"}},[t._v("#")]),t._v(" 문자열 수식 계산의 일반적 방법")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Step1 : 중위표기법의 수식을 후위표기법으로 변경\n    => 스택 이용\n    => 중위표기법(infix notation) : 연산자를 피연산자의 가운데 표기하는 방법\nStep2 : 후위표기법의 수식을 스택을 이용하여 계산\n    => 후위표기법(postfix notation) : 연산자를 피연산자 뒤에 표기하는 방법\n")])])]),a("h3",{attrs:{id:"step1-중위-표기-식을-후위-표기-식으로-변환-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step1-중위-표기-식을-후위-표기-식으로-변환-1"}},[t._v("#")]),t._v(" Step1. 중위 표기 식을 후위 표기 식으로 변환 1")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ex) A*B-C/D 변환 방법\n1. 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현\n    => ((A*B)-(C/D))\n2. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동\n    => ((A B)*(C D)/)-\n3. 괄호 제거\n    => AB*CD/-\n")])])]),a("h3",{attrs:{id:"step1-중위-표기-식을-후위-표기-식으로-변환-2-스택-이용"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step1-중위-표기-식을-후위-표기-식으로-변환-2-스택-이용"}},[t._v("#")]),t._v(" Step1. 중위 표기 식을 후위 표기 식으로 변환 2 (스택 이용)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 입력 받은 중위표기식에서 토큰을 읽음\n2. 토큰이 피연산자이면 토큰을 출력\n3. 토큰이 연산자(괄호 포함)일 경우\n    => top과 비교했을 경우 토큰이 우선순위가 높으면 -> 스택에 push\n    => top과 비교했을 경우 토큰이 우선순위가 안 높으면 -> 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 후 토큰의 연산자를 push\n    => 만약 top에 연산자가 없으면 -> push\n4. 토큰이 오른쪽 괄호 ')'일 경우\n    => 스택 top에 왼쪽 괄호 '('가 올 때까지 스택에 pop 연산을 수행\n    => pop한 연산자를 출력\n    => 왼쪽 괄호를 만나면 pop만 하고 출력하지는 않음\n5. 중위표기식에 더 읽을 것이 없다면 중지, 더 읽을 것이 있다면 1부터 반복\n6. 스택에 남아 있는 연산자를 모두 pop하여 출력\n    => 스택 밖의 왼쪽 괄호는 우선 순위가 가장 높으며, 스택 안의 왼쪽 괄호는 우선 순위가 가장 낮음\n")])])]),a("h3",{attrs:{id:"step2-후위-표기법의-수식을-스택을-이용하여-계산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step2-후위-표기법의-수식을-스택을-이용하여-계산"}},[t._v("#")]),t._v(" Step2. 후위 표기법의 수식을 스택을 이용하여 계산")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 피연산자를 만나면 스택에 push함\n2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산결과를 다시 스택에 push함\n3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력\n\n💡계산 시 주의사항!\n- 후위표기식을 계산 시, 피연산자를 스택에 쌓아 계산!\n")])])]),a("h3",{attrs:{id:"문자열로-된-수식을-계산-시"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#문자열로-된-수식을-계산-시"}},[t._v("#")]),t._v(" 문자열로 된 수식을 계산 시")]),t._v(" "),a("ul",[a("li",[t._v("스택을 두번 사용해서 처리했던 연산을 파이썬에서 제공하는 "),a("code",[t._v("eval() 내장 함수")]),t._v("로 계산할 수 있음")])]),t._v(" "),a("h4",{attrs:{id:"eval-수식"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eval-수식"}},[t._v("#")]),t._v(" eval(수식)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('- 문자열로 된 수식을 계산함\n- Evalution = "값을 구함"이란 뜻\n- 올바른 수식이 아닌 경우 SyntaxError 예외가 발생함\n- eval("6+5*(2-8)/2") 는 문자열로 된 수식의 계산결과를 반환함\n')])])]),a("br"),t._v(" "),a("h2",{attrs:{id:"_2-백트래킹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-백트래킹"}},[t._v("#")]),t._v(" 2. 백트래킹")]),t._v(" "),a("h3",{attrs:{id:"백트래킹-backtracking-이란"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#백트래킹-backtracking-이란"}},[t._v("#")]),t._v(" 백트래킹(Backtracking)이란?")]),t._v(" "),a("p",[t._v("해를 찾는 도중에 '막히면', (즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 기법"),a("br"),t._v("\n예를 들어, "),a("code",[t._v("최적화(Optimization)문제, 결정(Decision)문제")]),t._v(" 등이 있다.")]),t._v(" "),a("h3",{attrs:{id:"결정-decision-문제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#결정-decision-문제"}},[t._v("#")]),t._v(" 결정(Decision)문제")]),t._v(" "),a("p",[t._v("문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제")]),t._v(" "),a("ul",[a("li",[t._v("미로 찾기")]),t._v(" "),a("li",[t._v("n-Queen 문제")]),t._v(" "),a("li",[t._v("Map coloring")]),t._v(" "),a("li",[t._v("부분 집합의 합(Subset Sum) 문제 등")])]),t._v(" "),a("h4",{attrs:{id:"ex-백트래킹-기법-활용-미로-찾기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-백트래킹-기법-활용-미로-찾기"}},[t._v("#")]),t._v(" ex) 백트래킹 기법 활용 - 미로 찾기")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 입구와 출구가 주어진 미로에서 입구부터 출구까지의 경로를 찾는 문제\n2. 이동할 수 있는 방향은 4방향으로 제한\n    - 스택을 이용하여 지나온 경로를 역으로 되돌아 감\n    - 스택을 이용하여 다시 경로를 찾기\n")])])]),a("h3",{attrs:{id:"백트래킹과-깊이-우선-탐색의-차이"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#백트래킹과-깊이-우선-탐색의-차이"}},[t._v("#")]),t._v(" 백트래킹과 깊이 우선 탐색의 차이")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("백트래킹")])]),t._v(" "),a("ul",[a("li",[t._v("어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 "),a("code",[t._v("시도의 횟수를 줄임")])]),t._v(" "),a("li",[t._v("가지치기(Prunning)")]),t._v(" "),a("li",[t._v("불필요한 경로의 조기 차단")]),t._v(" "),a("li",[t._v("N!가지의 경우의 수를 가진 문제에 대해 백트레킹에 가하면 일반적으로  "),a("code",[t._v("경우의 수가 줄어들지만")]),t._v(" 이 역시 최악의 경우에는 여전히 지수함수 시간(Exponential Time)을 요하므로 처리 불가능")])])]),t._v(" "),a("li",[a("p",[a("code",[t._v("깊이 우선 탐색")])]),t._v(" "),a("ul",[a("li",[t._v("모든 경로를 추적")]),t._v(" "),a("li",[t._v("N!가지의 경우의 수를 가진 문제에 대해 깊이 우선 탐색을 가하면 "),a("code",[t._v("처리 불가능한 문제")])]),t._v(" "),a("li",[t._v("모든 후보를 검사")])])])]),t._v(" "),a("h3",{attrs:{id:"백트래킹-기법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#백트래킹-기법"}},[t._v("#")]),t._v(" 백트래킹 기법")]),t._v(" "),a("ul",[a("li",[t._v("어떤 노드의 유망성을 점검한 후에 유망(Promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(Backtracking) 다음 자식 노드로 감")]),t._v(" "),a("li",[t._v("어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 함")]),t._v(" "),a("li",[t._v("반대로 "),a("code",[t._v("해답의 가능성이 있으면 유망하다")]),t._v("고 함")]),t._v(" "),a("li",[t._v("가지치기(Prunnning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않음")])]),t._v(" "),a("h3",{attrs:{id:"백트래킹을-이용한-알고리즘의-절차"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#백트래킹을-이용한-알고리즘의-절차"}},[t._v("#")]),t._v(" 백트래킹을 이용한 알고리즘의 절차")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1. 상태 공간 Tree의 깊이 우선 검색을 실시\n2. 각 노드가 유망한지를 점검\n3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색을 계속\n")])])]),a("h4",{attrs:{id:"ex-n-queen"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-n-queen"}},[t._v("#")]),t._v(" ex) N-Queen")]),t._v(" "),a("p",[t._v("n*n의 정사각형 안에 n개의 queen을 배치하는 문제로, 모든 queen은 자신의 "),a("code",[t._v("일직선 상 및 대각선 상")]),t._v("에 아무 것도 놓이지 않아야 함")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 백트래킹을 사용한 N Queen 문제를 풀기 위한 파이썬 프로그램\ndef nqueen(arr, n):\n    global count\n\n    if len(arr) == n: # 정답 배열(arr)의 길이가 n과 같아지면, count 증가\n        count += 1\n        return 0\n    candidate = list(range(n)) # 0부터 n-1까지를 후보 배열로 만든다.\n    \n    for i in range(len(arr)):\n        # 같은 열에 있는 지 확인\n        if arr[i] in candidate: \n            candidate.remove(arr[i]) # 같은 열에 있다면 후보에서 제외\n        distance = len(arr) - i\n        \n        # 같은 대각성 상(+)에 있는 지 확인\n        if arr[i] + distance in candidate: \n            candidate.remove(arr[i] + distance) # 같은 대각선 상에 있다면 후보에서 제외\n        # 같은 대각선 상(-)에 있는 지 확인\n        if arr[i] - distance in candidate: \n            candidate.remove(arr[i] - distance) # 같은 대각선 상에 있다면 후보에서 제외\n\n    if candidate != []:\n        for i in candidate:\n            arr.append(i) # 후보의 요소를 정답 배열의 i+1로 추가\n            nqueen(arr, n) # 재귀적으로 다음 행도 확인\n    else:\n        return 0\n        \ncount = 0\nnum = int(input())\nfor i in range(num): # 첫 행의 경우의 수\nnqueen([i], num)\nprint(count)\n")])])]),a("h3",{attrs:{id:"power-set"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#power-set"}},[t._v("#")]),t._v(" Power Set")]),t._v(" "),a("ul",[a("li",[t._v("어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합")]),t._v(" "),a("li",[t._v("구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2^n이 나옴")])]),t._v(" "),a("h3",{attrs:{id:"백트래킹-기법으로-power-set-구하기"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#백트래킹-기법으로-power-set-구하기"}},[t._v("#")]),t._v(" 백트래킹 기법으로 Power Set 구하기")]),t._v(" "),a("ul",[a("li",[t._v("일반적인 백트래킹 접근 방법 이용")]),t._v(" "),a("li",[t._v("n개의 원소가 들어있는 집합의 2^n개의 부분집합을 만들 때, True또는 False 값을 가지는 항목들로 구성된 n개의 리스트를 만드는 방법 이용")]),t._v(" "),a("li",[a("code",[t._v("리스트의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값")])])]),t._v(" "),a("h4",{attrs:{id:"ex-power-set을-구하는-백트래킹-알고리즘-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-power-set을-구하는-백트래킹-알고리즘-예제"}},[t._v("#")]),t._v(" ex) Power Set을 구하는 백트래킹 알고리즘 예제")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위\ndef backtrack(a, k, input):\n    global MAXCANDIDATES\n    c = [0] * MAXCANDIDATES\n\n    if k == input:\n        process_solution(a, k) # powerset을 출력\n\n    else:\n        k+=1\n        ncandidates = construct_candidates(a, k, input, c) # 후보군 만들기 \n        for i in range(ncandidates):\n            a[k] = c[i] # 현재 단계에 후보군 하나를 넣음\n            backtrack(a, k, input) # 다음단계를 진행하도록 k단계를 재귀호출 \n\n# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위, c : 후보군을 저장할 배열\ndef construct_candidates(a, k, input, c):\n    c[0] = True\n    c[1] = False\n    return 2      # 후보군 갯수\n\n# 완성된 a 배열을 보고, 원소를 출력할지 확인해서 powerset을 출력\ndef process_solution(a, k):\n    print(\"(\", end='')\n    for i in range(k+1):\n        if a[i]:\n            print(i, end=' ')\n    print(\")\")\n\nMAXCANDIDATES = 100\nNMAX = 100\na = [0] * NMAX\nbacktrack(a, 0, 3)\n")])])]),a("h4",{attrs:{id:"ex-순열을-구하는-백트래킹-알고리즘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-순열을-구하는-백트래킹-알고리즘"}},[t._v("#")]),t._v(" ex) 순열을 구하는 백트래킹 알고리즘")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위\ndef backtrack(a, k, input):\n    global MAXCANDIDATES\n    c = [0] * MAXCANDIDATES\n\n    if k == input:\n        for i in range(1, k+1):\n            print(a[i], end=' ')\n        print()    \n    else:\n        k+=1\n        ncandidates = construct_candidates(a, k, input, c) # 후보군 만들기 \n        for i in range(ncandidates):\n            a[k] = c[i] # 현재 단계에 후보군 하나를 넣음\n            backtrack(a, k, input) # 다음단계를 진행하도록 k단계를 재귀호출 \n\n\n# a : 원소의 사용여부를 체크할 배열, k : 현재의 단계, input : 단계의 끝 범위, c : 후보군을 저장할 배열\ndef construct_candidates(a, k, input, c):\n    in_perm = [False] * NMAX\n\n    for i in range(1,k):\n        in_perm[a[i]] = True\n\n    ncandidates = 0\n\n    for i in range(1, input+1):\n        if in_perm[i] == False:\n            c[ncandidates] = i\n            ncandidates += 1\n\n    return ncandidates\n")])])]),a("br"),t._v(" "),a("h2",{attrs:{id:"_3-분할정복"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-분할정복"}},[t._v("#")]),t._v(" 3. 분할정복")]),t._v(" "),a("h3",{attrs:{id:"분할-정복-알고리즘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#분할-정복-알고리즘"}},[t._v("#")]),t._v(" 분할 정복 알고리즘")]),t._v(" "),a("ul",[a("li",[t._v("분할(Divide) : 해결할 문제를 "),a("code",[t._v("여러 개의 작은 부분")]),t._v("으로 나눔")]),t._v(" "),a("li",[t._v("정복(Conquer) : 나눈 작은 문제를 "),a("code",[t._v("각각 해결")])]),t._v(" "),a("li",[t._v("통합(Combine) : (필요하다면) 해결된 "),a("code",[t._v("해답을 모음")])])]),t._v(" "),a("h4",{attrs:{id:"거듭-제곱-exponentiation-알고리즘-o-n"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#거듭-제곱-exponentiation-알고리즘-o-n"}},[t._v("#")]),t._v(" 거듭 제곱(Exponentiation) 알고리즘 : O(n)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("def Power(Base, Exponent):\n    if Base == 0:   \n        return 1\n    result = 1 # Base^0은 1이므로\n    for i in range(Exponent):\n        result *= Base\n    return result\n")])])]),a("h4",{attrs:{id:"분할-정복-기반의-알고리즘-o-log2n"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#분할-정복-기반의-알고리즘-o-log2n"}},[t._v("#")]),t._v(" 분할 정복 기반의 알고리즘 : O(log2n)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("def Power(Base, Exponent):\n    if Exponent == 0 or Base == 0:\n        return 1\n    if Exponent % 2 == 0:\n        NewBase = Power(Base, Exponent/2)\n        return NewBase * NewBase\n    else:\n        NewBase = Power(Base, (Exponent-1)/2)\n        return (NewBase * NewBase) * Base\n")])])]),a("h3",{attrs:{id:"퀵-정렬과-합병-정렬의-비교"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#퀵-정렬과-합병-정렬의-비교"}},[t._v("#")]),t._v(" 퀵 정렬과 합병 정렬의 비교")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("정렬 비교")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("합병 정렬")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("퀵 정렬")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("공통점")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("주어진 리스트를 두 개로 분할하고, 각각을 정렬")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("(이하동문)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("차이점")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("분할할 때, 단순하게 두 부분으로 나눔")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("분할할 때, "),a("code",[t._v("기준 아이템(Pivot Item)")]),t._v("을 중심으로, 이보다 "),a("code",[t._v("작은 것은 왼편, 큰 것은 오른편")]),t._v("에 위치시킴")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}}),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("각 부분 정렬이 끝난 후, "),a("code",[t._v("합병이란 후처리 작업이 필요함")])]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("각 부분 정렬이 끝난 후, "),a("code",[t._v("후처리 작업이 필요로 하지 않음")])])])])]),t._v(" "),a("h3",{attrs:{id:"퀵-정렬-알고리즘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#퀵-정렬-알고리즘"}},[t._v("#")]),t._v(" 퀵 정렬 알고리즘")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("# 주어진 리스트에서 피봇을 구하는 알고리즘\ndef partition(a, begin, end):\n    pivot = (begin + end) // 2\n    L = begin\n    R = end\n\n    while L < R: # L과 R이 만나지 않을 경우\n        while(a[L] < a[pivot] and L < R):\n            L += 1\n        while(a[R] >= a[pivot] and L < R):\n            R -= 1\n        if L < R:\n            if L == pivot:\n                pivot = R\n            a[L], a[R] = a[R], a[L]\n\n    a[pivot], a[R] = a[R], a[pivot]\n    return R\n\n# 퀵 정렬 알고리즘\ndef quickSort(a, begin, end):\n    if begin < end:\n        p = partition(a, begin, end)\n        quickSort(a, begin, p-1)\n        quickSort(a, p+1, end)\n")])])]),a("h4",{attrs:{id:"퀵-정렬-수행-과정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#퀵-정렬-수행-과정"}},[t._v("#")]),t._v(" 퀵 정렬 수행 과정")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ex) a = [68, 11, 29, 3, 15, 9, 32, 23]\n\n1. 원소 2를 피봇으로 선택하고 퀵 정렬 시작하기\n2. 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기\n3. 피봇 15의 왼쪽 부분 집합에서 원소 10을 피봇으로 선택하여 퀵 정렬 수행하기 \n4. 원소 16에 대한 오른쪽 부분 집합에 대해 퀵 정렬을 수행하기\n5. 오른쪽 부분 집합에 대해서 퀵 정렬 수행하기 \n")])])]),a("ul",[a("li",[t._v("퀵 정렬의 최악의 시간 복잡도는 "),a("code",[t._v("O(n^2)")]),t._v(" ⇒ 합병정렬에 비해 좋지 못함")]),t._v(" "),a("li",[t._v("퀵 정렬의 평균 복잡도는 "),a("code",[t._v("nlogn")]),t._v("이기 때문에 빠른(Quick) 정렬이라고 함")])]),t._v(" "),a("h3",{attrs:{id:"퀵-정렬의-특성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#퀵-정렬의-특성"}},[t._v("#")]),t._v(" 퀵 정렬의 특성")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("알고리즘")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("평균 수행 시간")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("최악 수행 시간")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("알고리즘 기법")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("비고")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("퀵 정렬")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(nlogn)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("O(n^2)")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("분할 정복")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("최악의 경우 O(n^2)이지만, 평균적으로는 가장 빠름")])])])]),t._v(" "),a("br"),t._v(" "),a("h2",{attrs:{id:"reference-additional-resources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[t._v("#")]),t._v(" Reference & Additional Resources")]),t._v(" "),a("blockquote",[a("p",[t._v("SW Expert Academy")])])])}),[],!1,null,null,null);e.default=r.exports}}]);