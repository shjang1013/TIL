(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{279:function(t,_,v){"use strict";v.r(_);var a=v(19),e=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"시작하기"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시작하기"}},[t._v("#")]),t._v(" 시작하기")]),t._v(" "),v("p",[v("em",[t._v("written by sohyeon")]),t._v("🍀")]),t._v(" "),v("br"),t._v(" "),v("h2",{attrs:{id:"_1-sw-문제-해결"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-sw-문제-해결"}},[t._v("#")]),t._v(" 1. SW 문제 해결")]),t._v(" "),v("h3",{attrs:{id:"프로그래밍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#프로그래밍"}},[t._v("#")]),t._v(" 프로그래밍")]),t._v(" "),v("p",[v("code",[t._v("프로그래밍을 잘하는 사람과 못하는 사람의 생산성 차이는 20배")])]),t._v(" "),v("ul",[v("li",[t._v("프로그래밍하기 위한 제약 조건과 요구사항\n"),v("ul",[v("li",[t._v("프로그래밍 언어의 특성")]),t._v(" "),v("li",[t._v("프로그램이 동작할 H/W와 OS에 관한 지식")]),t._v(" "),v("li",[t._v("라이브러리들이 유의 사항들")]),t._v(" "),v("li",[t._v("프로그램이 사용할 수 있는 최대 메모리")]),t._v(" "),v("li",[t._v("사용자 대응 시간 제한")]),t._v(" "),v("li",[t._v("재사용성이 높은 간결한 코드")])])])]),t._v(" "),v("h3",{attrs:{id:"sw-문제-해결-역량"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sw-문제-해결-역량"}},[t._v("#")]),t._v(" SW 문제 해결 역량")]),t._v(" "),v("p",[t._v("프로그램 작성을 위한 많은 "),v("code",[t._v("제약 조건들과 요구사항들을 이해")]),t._v("하고 "),v("code",[t._v("최선의 방법을 찾아내는 능력")])]),t._v(" "),v("ul",[v("li",[t._v("프로그래머가 사용하는 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 "),v("code",[t._v("적재적소에 연결하여 큰 그림을 만드는 능력")])]),t._v(" "),v("li",[t._v("문제 해결 역량은 "),v("code",[t._v("추상적인 기술")]),t._v(" "),v("ul",[v("li",[t._v("명확히 정의된 실체가 없음")]),t._v(" "),v("li",[t._v("알고리즘들을 암기하고 문제를 풀어본다고 향상되지 않음")])])]),t._v(" "),v("li",[t._v("문제 해결 역량 향상을 위해서 훈련 필요")])]),t._v(" "),v("h3",{attrs:{id:"문제-해결-능력을-향상시키는-훈련"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#문제-해결-능력을-향상시키는-훈련"}},[t._v("#")]),t._v(" 문제 해결 능력을 향상시키는 훈련")]),t._v(" "),v("ul",[v("li",[t._v("새로운 언어, 프레임워크, 개발 방법론들의 "),v("code",[t._v("조합 방법을 배워야 함")])]),t._v(" "),v("li",[t._v("프로그래밍 경험을 통해서 나아질 것이라는 기대를 하지 않아야 함\n"),v("ul",[v("li",[t._v("경험에서 문제 해결 능력 개발 가능한 상황이 항상 주어지지 않음")]),t._v(" "),v("li",[t._v("문제 해결 능력 개발 가능한 상황에서 자기 계발하기 어려움")])])]),t._v(" "),v("li",[v("code",[t._v("인위적 상황을 만들어 훈련")]),t._v("해야 함\n"),v("ul",[v("li",[v("code",[t._v("정제된 추상적인 문제를 제시")]),t._v("하고 해결하면서 문제 해결 능력을 향상시킬 수 있는 "),v("code",[t._v("훈련 필요")])])])])]),t._v(" "),v("h3",{attrs:{id:"문제-해결-과정"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#문제-해결-과정"}},[t._v("#")]),t._v(" 문제 해결 과정")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("1. 문제를 읽고 이해하기\n2. 문제를 익숙한 용어로 재정의하기\n3. 어떻게 해결할지 계획 세우기\n4. 계획 검증하기\n5. 프로그램으로 구현하기\n6. 풀이를 돌아보고, 개선할 방법 찾기\n")])])]),v("h3",{attrs:{id:"문제-해결-전략"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#문제-해결-전략"}},[t._v("#")]),t._v(" 문제 해결 전략")]),t._v(" "),v("p",[v("code",[t._v("직관")]),t._v("과 "),v("code",[t._v("체계적")]),t._v("인 접근")]),t._v(" "),v("ul",[v("li",[t._v("체계적인 접근을 위한 질문들\n"),v("ul",[v("li",[t._v("비슷한 문제를 풀어본 적이 있던가?")]),t._v(" "),v("li",[t._v("단순한 방법에서 시작할 수 있을까?")]),t._v(" "),v("li",[t._v("문제를 단순화 할 수 있을까?, 그림으로 그려볼 수 있을까?, 수식으로 표현할 수 있을까?")]),t._v(" "),v("li",[t._v("문제를 분해할 수 있을까?")]),t._v(" "),v("li",[t._v("뒤에서부터 생각해서 문제를 풀 수 있을까?")]),t._v(" "),v("li",[t._v("특정 형태의 답만을 고려할 수 있을까?")])])])]),t._v(" "),v("br"),t._v(" "),v("h2",{attrs:{id:"_2-알고리즘-복잡도"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-알고리즘-복잡도"}},[t._v("#")]),t._v(" 2. 알고리즘 복잡도")]),t._v(" "),v("h3",{attrs:{id:"알고리즘"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#알고리즘"}},[t._v("#")]),t._v(" 알고리즘")]),t._v(" "),v("p",[t._v("유한한 단계를 통해 문제를 해결하기 위한 절차나 방법")]),t._v(" "),v("h3",{attrs:{id:"알고리즘의-효율"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#알고리즘의-효율"}},[t._v("#")]),t._v(" 알고리즘의 효율")]),t._v(" "),v("p",[t._v("같은 문제에 대한 다른 알고리즘들이 구현되어 컴퓨터에서 실행되는 경우 "),v("code",[t._v("입력 크기가 클수록")]),t._v(" 알고리즘의 효율에 따라 실행 시간의 차이 발생")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("공간적 효율성")]),t._v(" "),v("ul",[v("li",[t._v("얼마나 많은 메모리 공간을 요하는가?")])])]),t._v(" "),v("li",[v("p",[t._v("시간적 효율성")]),t._v(" "),v("ul",[v("li",[t._v("얼마나 많은 시간을 요하는가?")])])]),t._v(" "),v("li",[v("p",[t._v("복잡도가 높을수록 효율성 저하")])])]),t._v(" "),v("h3",{attrs:{id:"시간-또는-공간-복잡도의-점근적-표기"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#시간-또는-공간-복잡도의-점근적-표기"}},[t._v("#")]),t._v(" 시간(또는 공간) 복잡도의 점근적 표기")]),t._v(" "),v("ul",[v("li",[t._v("입력 크기에 대한 함수로 표기 ( 함수는 다항식 )")]),t._v(" "),v("li",[t._v("단순한 함수로 표현하기 위해 "),v("code",[t._v("점근적 표기(Asymptotic Notation) 사용")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("점근적 표기")]),t._v("란? 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법")]),t._v(" "),v("li",[v("code",[t._v("Big-Oh 표기")]),t._v(", "),v("code",[t._v("Big-Omega 표기")]),t._v(", "),v("code",[t._v("Theta 표기")])])])])]),t._v(" "),v("h3",{attrs:{id:"점근적-상한"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#점근적-상한"}},[t._v("#")]),t._v(" 점근적 상한")]),t._v(" "),v("ul",[v("li",[t._v("Big-Oh 표기\n"),v("ul",[v("li",[t._v("단순화된 함수 n^2에 "),v("code",[t._v("임의의 상수 c를 곱한 cn^2이 n이 증가함에 따라 f(n)의 상한이 됨")]),t._v(" ( 단, c>0 )")])])])]),t._v(" "),v("h3",{attrs:{id:"점근적-하한"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#점근적-하한"}},[t._v("#")]),t._v(" 점근적 하한")]),t._v(" "),v("ul",[v("li",[t._v("Big-Omega 표기\n"),v("ul",[v("li",[t._v("f(n) = Omega(n^2)은 "),v("code",[t._v("n이 증가함에 따라 2n^2-7n+4가 cn^2보다 작을 수 없다")]),t._v(" 라는 의미로 상수 c=1로 놓으면 됨")]),t._v(" "),v("li",[t._v("Omega-표기도 복잡도 다항식의 최고차항만 계수 없이 취함")]),t._v(" "),v("li",[v("code",[t._v("최소한 이만한 시간은 걸린다")]),t._v("라는 것을 의미")])])])]),t._v(" "),v("h3",{attrs:{id:"점근적-상한과-하한이-동일"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#점근적-상한과-하한이-동일"}},[t._v("#")]),t._v(" 점근적 상한과 하한이 동일")]),t._v(" "),v("ul",[v("li",[t._v("Theta 표기\n"),v("ul",[v("li",[t._v("Big-Oh 표기와 Big-Omega 표기가 같은 경우에 사용")]),t._v(" "),v("li",[t._v("f(n)은 n이 증가함에 따라 "),v("code",[t._v("n^2과 동일한 증가율을 가진다")]),t._v("라는 의미")])])])]),t._v(" "),v("h3",{attrs:{id:"자주-사용하는-o-표기"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#자주-사용하는-o-표기"}},[t._v("#")]),t._v(" 자주 사용하는 O-표기")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("O(1)")]),t._v(": 상수 시간(Constant time)")]),t._v(" "),v("li",[v("code",[t._v("O(logn)")]),t._v(": 로그(대수) 시간(Logarithmic time)")]),t._v(" "),v("li",[v("code",[t._v("O(n)")]),t._v(": 선형 시간(Linear time)")]),t._v(" "),v("li",[v("code",[t._v("O(nlogn)")]),t._v(": 로그 선형 시간(Log-linear time)")]),t._v(" "),v("li",[v("code",[t._v("O(n^2)")]),t._v(": 제곱 시간(Quadratic time)")]),t._v(" "),v("li",[v("code",[t._v("O(n^3)")]),t._v(": 세제곱 시간(Cubic time)")]),t._v(" "),v("li",[v("code",[t._v("O(2^n)")]),t._v(": 지수 시간(Exponential time)")])]),t._v(" "),v("h3",{attrs:{id:"효율적-알고리즘의-필요성"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#효율적-알고리즘의-필요성"}},[t._v("#")]),t._v(" 효율적 알고리즘의 필요성")]),t._v(" "),v("ul",[v("li",[t._v("10억 개의 숫자를 정렬하는데 PC에서 O(n^2) 알고리즘은 300여 년이 걸리는 반면에 O(nlogn) 알고리즘은 5분 만에 정렬")]),t._v(" "),v("li",[t._v("효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음")]),t._v(" "),v("li",[t._v("값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 더 경제적")])]),t._v(" "),v("br"),t._v(" "),v("h2",{attrs:{id:"_3-비트-연산"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-비트-연산"}},[t._v("#")]),t._v(" 3. 비트 연산")]),t._v(" "),v("h3",{attrs:{id:"비트-연산자"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#비트-연산자"}},[t._v("#")]),t._v(" 비트 연산자")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("연산자")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("연산자의 기능")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("예시")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("&")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("비트단위로 AND 연산을 한다.")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) num1 & num2")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("|")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("비트단위로 OR 연산을 한다.")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) num1")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("^")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("비트단위로 XOR 연산을 한다. (같으면 0 다르면 1)")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) num1 ^ num2")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("~")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("단항 연산자로서 피연산자의 모든 비트를 반전시킨다.")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) ~num")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v("<<")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("피연산자의 비트 열을 왼쪽으로 이동시킨다.")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) num << 2")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("code",[t._v(">>")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("피연산자의 비트 열을 오른쪽으로 이동시킨다.")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("예) num >> 2")])])])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("프로그램에서 비트 연산 적용 시  "),v("code",[t._v("연산 속도를 향상시키거나 메모리 절약 가능")])])]),t._v(" "),v("li",[v("p",[t._v("1 << n")]),t._v(" "),v("ul",[v("li",[t._v("2^n의 값을 가짐")]),t._v(" "),v("li",[t._v("원소가 n개일 경우의 모든 부분집합의 수를 의미")]),t._v(" "),v("li",[t._v("Power set(모든 부분 집합)\n"),v("ul",[v("li",[t._v("공집합과 자기 자신을 포함한 모든 부분집합")]),t._v(" "),v("li",[t._v("각 원소가 포함되거나 포함되지 않는 2가지 경우의 수를 계산하면 모든 부분집합의 수가 계산됨")])])])])]),t._v(" "),v("li",[v("p",[t._v("i & ( 1 << j )")]),t._v(" "),v("ul",[v("li",[t._v("계산 결과는 "),v("code",[t._v("i의 j번째 비트가 1인지 아닌지를 의미")])])])])]),t._v(" "),v("h3",{attrs:{id:"비트-연산-예제"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#비트-연산-예제"}},[t._v("#")]),t._v(" 비트 연산 예제")]),t._v(" "),v("h4",{attrs:{id:"비트-연산1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#비트-연산1"}},[t._v("#")]),t._v(" 비트 연산1")]),t._v(" "),v("p",[t._v("특정 위치의 비트값을 확인하는 수식에 대한 예제")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('def BitPrint(i):\n    for j in range(7, -1, -1):\n        print(\'1\' if (i & (1 << j)) else \'0\', end="")\n        # print("%d" %((i >> j) & 1), end="")\n\nfor i in range(-5,6):\n    print("%2d = " %i, end="") # 십진수 출력\n    BitPrint(i) # 이진수 출력\n    print()\n')])])]),v("h3",{attrs:{id:"엔디안-endianness"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#엔디안-endianness"}},[t._v("#")]),t._v(" 엔디안(Endianness)")]),t._v(" "),v("p",[t._v("컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하여 HW 아키텍처마다 다름")]),t._v(" "),v("ul",[v("li",[t._v("빅 엔디안(Big-endian)\n"),v("ul",[v("li",[t._v("보통 큰 단위가 앞에 나옴")]),t._v(" "),v("li",[t._v("네트워크")])])]),t._v(" "),v("li",[t._v("리틀 엔디안(Little-endian)\n"),v("ul",[v("li",[t._v("작은 단위가 앞에 나옴")]),t._v(" "),v("li",[t._v("대다수 데스크탑 컴퓨터")])])])]),t._v(" "),v("h4",{attrs:{id:"비트-연산2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#비트-연산2"}},[t._v("#")]),t._v(" 비트 연산2")]),t._v(" "),v("p",[t._v("자신의 컴퓨터가 어떤 엔디안 방식인지 확인하는 코드")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('n = 0x00111111\n\nif n & 0x11:\n    print("little endian") # 11 11 11 00\nelse:\n    print("big endian") # 00 11 11 11\n')])])]),v("br"),t._v(" "),v("h2",{attrs:{id:"_4-진수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-진수"}},[t._v("#")]),t._v(" 4. 진수")]),t._v(" "),v("h3",{attrs:{id:"진법-변환"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#진법-변환"}},[t._v("#")]),t._v(" 진법 변환")]),t._v(" "),v("ul",[v("li",[t._v("10진수를 "),v("code",[t._v("타 진수로 변환")]),t._v("하는 방법\n"),v("ul",[v("li",[t._v("원하는 타진법의 수로 나눈 뒤 나머리를 거꾸로 읽음")])])]),t._v(" "),v("li",[t._v("타 진수를 "),v("code",[t._v("10진수로 변환")]),t._v("하는 방법\n"),v("ul",[v("li",[t._v("각 자릿값을 행당 진수의 값을 곱해서 구함")])])]),t._v(" "),v("li",[t._v("2진수, 8진수, 16진수간 변환\n"),v("ul",[v("li",[t._v("16진수 표현이 2진수 4비트 형태로 표현 - 2진수 네 자리씩 묶어서 16진수로 표현")]),t._v(" "),v("li",[t._v("8진수는 2진수 세 자리씩 묶어서 표현")]),t._v(" "),v("li",[t._v("8진수와 16진수의 각 자리들을 세 자리와 네 자리로 풀어서 나열하여 2진수로 변환")])])])]),t._v(" "),v("h3",{attrs:{id:"음의-정수-표현"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#음의-정수-표현"}},[t._v("#")]),t._v(" 음의 정수 표현")]),t._v(" "),v("ul",[v("li",[t._v("1의 보수\n"),v("ul",[v("li",[t._v("부호와 절대값으로 표현된 값을 부호 비트를 제외한 나머지 비트들을 0은 1로, 1은 0로 변환")])])]),t._v(" "),v("li",[t._v("2의 보수\n"),v("ul",[v("li",[t._v("1의 보수방법으로 표현된 값의 최하위 비트에 1을 더함")])])])]),t._v(" "),v("br"),t._v(" "),v("h2",{attrs:{id:"_5-실수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-실수"}},[t._v("#")]),t._v(" 5. 실수")]),t._v(" "),v("h3",{attrs:{id:"_2진-실수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2진-실수"}},[t._v("#")]),t._v(" 2진 실수")]),t._v(" "),v("ul",[v("li",[t._v("2진 실수를 10진수로 변환하는 방법\n"),v("ul",[v("li",[t._v("각 자릿값을 2진수의 값을 곱해서 구함")])])])]),t._v(" "),v("h3",{attrs:{id:"부동-소수점-표기법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#부동-소수점-표기법"}},[t._v("#")]),t._v(" 부동 소수점 표기법")]),t._v(" "),v("p",[t._v("소수점의 위치를 고정시켜 표현하는 방식으로, 소수점의 위치를 왼쪽의 가장 유효한 숫자 다음으로 고정시키고 밑수의 지수승으로 표현")]),t._v(" "),v("p",[t._v("컴퓨터에서의 실수 저장 형식에는 "),v("code",[t._v("단정도 실수(32비트)")]),t._v(", "),v("code",[t._v("배정도 실수(64비트)")]),t._v(" 등이 있다.")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("단정도 실수(32비트)")]),t._v(" "),v("ul",[v("li",[t._v("부호, 가수부, 지수부로 구분하여 저장")]),t._v(" "),v("li",[v("code",[t._v("부호 1비트, 지수 8비트, 가수 23비트")])]),t._v(" "),v("li",[t._v("가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것")]),t._v(" "),v("li",[t._v("지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것")])])]),t._v(" "),v("li",[v("p",[t._v("배정도 실수(64비트)")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("부호 1비트, 지수 11비트, 가수 52비트")])])])])]),t._v(" "),v("p",[t._v("파이썬에서 실수 표현은 단정도 실수는 사용하지 않고 8바이트 크기의 float 타입 배정도 실수로만 처리한다."),v("br"),t._v(" "),v("br")]),t._v(" "),v("h4",{attrs:{id:"단정도-실수의-가수-부분을-만드는-방법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#단정도-실수의-가수-부분을-만드는-방법"}},[t._v("#")]),t._v(" 단정도 실수의 가수 부분을 만드는 방법")]),t._v(" "),v("p",[v("code",[t._v("예) 1001.0011")])]),t._v(" "),v("ul",[v("li",[t._v("정수부의 첫 번째 자리가 1이 되도록 소소점 오른쪽으로 이동")]),t._v(" "),v("li",[t._v("소수점 이하를 23비트로 만듦")]),t._v(" "),v("li",[t._v("소수점 이하만을 가수 부분에 저장")]),t._v(" "),v("li",[t._v("지수 부분은 시프트 한 자릿수 만큼 증가 또는 감소")])]),t._v(" "),v("h4",{attrs:{id:"단정도-실수의-지수-부분을-만드는-방법"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#단정도-실수의-지수-부분을-만드는-방법"}},[t._v("#")]),t._v(" 단정도 실수의 지수 부분을 만드는 방법")]),t._v(" "),v("ul",[v("li",[t._v("지수부는 숫자로 0-255(8비트)까지 나타낼 수 있지만, "),v("code",[t._v("음수 값을 나타낼 수 있어야 하기 때문에 익세스(Excess) 표현법 사용")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("익세스(Excess)표현법")]),t._v(" : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법")]),t._v(" "),v("li",[t._v("실제 지수 + 127")])])])]),t._v(" "),v("h3",{attrs:{id:"유효-숫자"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#유효-숫자"}},[t._v("#")]),t._v(" 유효 숫자")]),t._v(" "),v("p",[t._v("이진법으로 표현할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장하는데, 근사값으로 저장될 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져온다.")]),t._v(" "),v("h4",{attrs:{id:"실수-자료형의-유효-자릿수"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#실수-자료형의-유효-자릿수"}},[t._v("#")]),t._v(" 실수 자료형의 유효 자릿수")]),t._v(" "),v("ul",[v("li",[t._v("32비트 실수형 유효자릿수(십진수) => 6")]),t._v(" "),v("li",[t._v("64비트 실수형 유효자릿수(십진수) => 15\n"),v("br")])]),t._v(" "),v("h2",{attrs:{id:"reference-additional-resources"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[t._v("#")]),t._v(" Reference & Additional Resources")]),t._v(" "),v("blockquote",[v("p",[t._v("SW Expert Academy")])])])}),[],!1,null,null,null);_.default=e.exports}}]);