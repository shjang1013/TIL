(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{376:function(e,a,p){"use strict";p.r(a);var h=p(27),t=Object(h.a)({},(function(){var e=this,a=e.$createElement,p=e._self._c||a;return p("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[p("h1",{attrs:{id:"heapq-모듈"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heapq-모듈"}},[e._v("#")]),e._v(" heapq 모듈")]),e._v(" "),p("p",[e._v("written by sohyeon, hyemin, youngcheol 💡")]),e._v(" "),p("br"),e._v(" "),p("h2",{attrs:{id:"heapq-모듈-2"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heapq-모듈-2"}},[e._v("#")]),e._v(" heapq 모듈")]),e._v(" "),p("p",[p("code",[e._v("heapq모듈")]),e._v("은 이진 트리(binary tree) 기반의 최소 힙(min heap) 자료구조를 제공한다."),p("br"),e._v("\n자바의 "),p("code",[e._v("PriorityQueue클래스")]),e._v("를 생각하면 된다.")]),e._v(" "),p("ul",[p("li",[e._v("힙은 모든 부모 노드가 자식보다 작거나 같은 값을 갖는 이진 트리\n"),p("ul",[p("li",[e._v("모든 k에 대해 "),p("code",[e._v("heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2]")])])])]),e._v(" "),p("li",[e._v("가장 작은 요소가 항상 루트에 위치 => heap[0]")])]),e._v(" "),p("h3",{attrs:{id:"최소-힙-생성"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#최소-힙-생성"}},[e._v("#")]),e._v(" 최소 힙 생성")]),e._v(" "),p("p",[p("code",[e._v("heapq모듈")]),e._v("에는 파이썬의 리스트를 마치 최소 힙처럼 다룰 수 있도록 도와준다.")]),e._v(" "),p("ul",[p("li",[e._v("빈 리스트를 생성하여 heapq 모듈의 함수를 호출할 때마다 이 리스트를 인자로 넘긴다.")]),e._v(" "),p("li",[e._v("최소 힙은 "),p("code",[e._v("heapq모듈")]),e._v("을 통해서 원소를 추가하거나 삭제한 리스트를 말한다.")])]),e._v(" "),p("h3",{attrs:{id:"heappush-heap-item"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heappush-heap-item"}},[e._v("#")]),e._v(" heappush(heap, item)")]),e._v(" "),p("p",[p("code",[e._v("heappush()")]),e._v("는 힙의 불변성을 유지하면서, 힙에 원소를 추가한다.")]),e._v(" "),p("h4",{attrs:{id:"heappush-heap-item-예제"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heappush-heap-item-예제"}},[e._v("#")]),e._v(" heappush(heap, item) 예제")]),e._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[e._v("heapq.heappush(heap, 5)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 8)\nheapq.heappush(heap, 3)\nprint(heap)\n")])])]),p("p",[e._v("결과 : "),p("code",[e._v("[1, 3, 8, 5]")])]),e._v(" "),p("p",[e._v("인덱스 0에 가장 작은 수인 1이 위치하며, 이진 트리에 원소를 추가하는 "),p("code",[e._v("heappush() 함수")]),e._v("  는 "),p("code",[e._v("O(logN)")]),e._v("의 시간 복잡도를 가진다.")]),e._v(" "),p("h3",{attrs:{id:"heappop-heap"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heappop-heap"}},[e._v("#")]),e._v(" heappop(heap)")]),e._v(" "),p("p",[p("code",[e._v("heappop()")]),e._v("는 힙의 불변성을 유지하면서, 힙의 원소를 삭제한다.")]),e._v(" "),p("ul",[p("li",[e._v("원소를 삭제할 리스트를 인자로 넘기면, 가장 작은 원소를 삭제 후에 그 값을 리턴한다.")]),e._v(" "),p("li",[e._v("힙이 비어 있으면, "),p("code",[e._v("IndexError")]),e._v("가 발생한다.")]),e._v(" "),p("li",[e._v("pop()하지 않고, 가장 작은 원소에 접근하고 싶을 경우 "),p("code",[e._v("heap[0]")]),e._v("을 사용한다.")])]),e._v(" "),p("h4",{attrs:{id:"heappop-heap-예제"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heappop-heap-예제"}},[e._v("#")]),e._v(" heappop(heap) 예제")]),e._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[e._v("print(heapq.heappop(heap))\nprint(heap) # 제일 작은 원소를 삭제 후에 다시 힙으로 변환 \n")])])]),p("p",[e._v("결과 :"),p("br"),e._v(" "),p("code",[e._v("1")]),p("br"),e._v(" "),p("code",[e._v("[3, 5, 8]")])]),e._v(" "),p("h3",{attrs:{id:"heapify-x"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heapify-x"}},[e._v("#")]),e._v(" heapify(x)")]),e._v(" "),p("p",[p("code",[e._v("heapify(x)")]),e._v("는 리스트 x를 힙으로 변환한다.")]),e._v(" "),p("ul",[p("li",[p("code",[e._v("heapify()")]),e._v("에 리스트를 인자로 넘기면 리스트 내부의 원소들이 힙 구조에 맞게 재배치되며, 최솟값이 0번째 인덱스에 위치한다.")]),e._v(" "),p("li",[p("code",[e._v("heapify()")]),e._v("는 O(N)의 시간 복잡도를 가진다.")])]),e._v(" "),p("h4",{attrs:{id:"heapify-x-예제"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#heapify-x-예제"}},[e._v("#")]),e._v(" heapify(x) 예제")]),e._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[e._v("List = [3, 5, 2, 8, 1, 4]\nheapq.heapify(heap)\nprint(List)\n")])])]),p("p",[e._v("결과 : "),p("code",[e._v("[1, 3, 2, 8, 5, 4]")])]),e._v(" "),p("h3",{attrs:{id:"최대-힙-생성"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#최대-힙-생성"}},[e._v("#")]),e._v(" 최대 힙 생성")]),e._v(" "),p("p",[p("code",[e._v("heapq모듈")]),e._v("은 최소 힙의 기능을 동작하기 때문에 최대 힙을 활용하려면 "),p("code",[e._v("튜플(tuple)")]),e._v("을 이용해야 한다.")]),e._v(" "),p("ul",[p("li",[e._v("힙에 튜플(tuple)을 원소로 추가하거나 삭제하면 "),p("code",[e._v("튜플 내에서 앞에 있는 값(-i)")]),e._v("을 기준으로 최소 힙이 구성되는 원리를 이용한다.")]),e._v(" "),p("li",[e._v("힙에서 값을 읽어올 때는 각 튜플에서 인덱스 1의 값을 읽어오면 된다.")])]),e._v(" "),p("h4",{attrs:{id:"최대-힙-예제"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#최대-힙-예제"}},[e._v("#")]),e._v(" 최대 힙 예제")]),e._v(" "),p("div",{staticClass:"language- extra-class"},[p("pre",{pre:!0,attrs:{class:"language-text"}},[p("code",[e._v("import heapq\n\nList = [3, 5, 2, 8, 1, 4]\nheap = []\n\nfor i in List:\n    heapq.heappush(heap, (-i, i)) # (우선 순위, 값)\n\nwhile heap:\n    print(heapq.heappop(heap)[1])\n")])])]),p("p",[e._v("결과 :"),p("br"),e._v(" "),p("code",[e._v("8")]),p("br"),e._v(" "),p("code",[e._v("5")]),p("br"),e._v(" "),p("code",[e._v("4")]),p("br"),e._v(" "),p("code",[e._v("3")]),p("br"),e._v(" "),p("code",[e._v("2")]),p("br"),e._v(" "),p("code",[e._v("1")])]),e._v(" "),p("br"),e._v(" "),p("h2",{attrs:{id:"reference-additional-resources"}},[p("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[e._v("#")]),e._v(" Reference & Additional Resources")]),e._v(" "),p("ul",[p("li",[p("a",{attrs:{href:"https://www.daleseo.com/python-heapq/",target:"_blank",rel:"noopener noreferrer"}},[e._v("heapq 모듈 사용법"),p("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=t.exports}}]);