(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{387:function(e,r,a){"use strict";a.r(r);var t=a(27),v=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree"}},[e._v("#")]),e._v(" Tree")]),e._v(" "),a("p",[a("em",[e._v("written by sohyeon")]),e._v("🍀")]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_1-tree의-특성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-tree의-특성"}},[e._v("#")]),e._v(" 1. Tree의 특성")]),e._v(" "),a("h3",{attrs:{id:"tree의-개념"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree의-개념"}},[e._v("#")]),e._v(" Tree의 개념")]),e._v(" "),a("p",[e._v("비선형 구조로 원소들 간에 1 : n 관계를 가지는 자료구조")]),e._v(" "),a("ol",[a("li",[e._v("원소들 간에 계층 관계를 가지는 계층형 자료구조")]),e._v(" "),a("li",[e._v("상위 원소에서 하위 원소로 내려가면서 확장되는 "),a("code",[e._v("Tree(나무)모양의 구조")])])]),e._v(" "),a("h3",{attrs:{id:"tree의-특성"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree의-특성"}},[e._v("#")]),e._v(" Tree의 특성")]),e._v(" "),a("ol",[a("li",[e._v("한 개 이상의 노드로 이루어진 유한 집합")])]),e._v(" "),a("ul",[a("li",[e._v("루트(Root) : 노드 중 최상위 노드")]),e._v(" "),a("li",[e._v("나머지 노드들: n개의 분리 집합 T1, ... ,TN으로 분리될 수 있음")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("이들 T1, ... ,TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 "),a("code",[e._v("서브트리(SubTree)")]),e._v("라고 함")])]),e._v(" "),a("h3",{attrs:{id:"tree의-구성요소"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tree의-구성요소"}},[e._v("#")]),e._v(" Tree의 구성요소")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("노드(node)")]),e._v(" "),a("ul",[a("li",[e._v("트리의 원소")])])]),e._v(" "),a("li",[a("code",[e._v("간선(edge)")]),e._v(" "),a("ul",[a("li",[e._v("노드를 연결하는 선")]),e._v(" "),a("li",[e._v("부모 노드와 자식 노드를 연결")])])]),e._v(" "),a("li",[a("code",[e._v("루트 노드(Root node)")]),e._v(" "),a("ul",[a("li",[e._v("트리의 시작 노드")])])]),e._v(" "),a("li",[a("code",[e._v("형제 노드(Sibling node)")]),e._v(" "),a("ul",[a("li",[e._v("같은 부모 노드의 자식 노드들")])])]),e._v(" "),a("li",[a("code",[e._v("조상 노드(Ancestor node)")]),e._v(" "),a("ul",[a("li",[e._v("간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들")])])]),e._v(" "),a("li",[a("code",[e._v("서브트리(SubTree)")]),e._v(" "),a("ul",[a("li",[e._v("부모 노드와 연결된 간선을 끊었을 때 생성되는 트리")])])]),e._v(" "),a("li",[a("code",[e._v("자손 노드(Descendent node)")]),e._v(" "),a("ul",[a("li",[e._v("서브트리에 있는 하위 레벨의 노드들")])])]),e._v(" "),a("li",[a("code",[e._v("차수(degree)")]),e._v(" "),a("ul",[a("li",[e._v("노드의 연결된 자식 노드의 수")]),e._v(" "),a("li",[e._v("트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값")])])]),e._v(" "),a("li",[a("code",[e._v("단말 노드(리프 노드)")]),e._v(" "),a("ul",[a("li",[e._v("차수가 0인 노드")]),e._v(" "),a("li",[e._v("자식 노드가 없는 노드")])])]),e._v(" "),a("li",[a("code",[e._v("높이")]),e._v(" "),a("ul",[a("li",[e._v("노드의 높이: 노드의 레벨")]),e._v(" "),a("li",[e._v("트리의 높이\n"),a("ul",[a("li",[e._v("트리에 있는 노드의 높이 중에서 가장 큰 값")]),e._v(" "),a("li",[e._v("최대 레벨")])])])])])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_2-binary-tree의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-binary-tree의-특징"}},[e._v("#")]),e._v(" 2. Binary Tree의 특징")]),e._v(" "),a("h3",{attrs:{id:"binary-tree의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-tree의-특징"}},[e._v("#")]),e._v(" Binary Tree의 특징")]),e._v(" "),a("ol",[a("li",[e._v("모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리")]),e._v(" "),a("li",[e._v("노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리")]),e._v(" "),a("li",[e._v("레벨 i에서의 노드의 최대 개수는 2^i개")]),e._v(" "),a("li",[e._v("높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개, 최대 개수는 2^(h+1)-1개가 됨")])]),e._v(" "),a("h3",{attrs:{id:"binary-tree의-종류"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-tree의-종류"}},[e._v("#")]),e._v(" Binary Tree의 종류")]),e._v(" "),a("h4",{attrs:{id:"포화-이진-트리-full-binary-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#포화-이진-트리-full-binary-tree"}},[e._v("#")]),e._v(" 포화 이진 트리(Full binary Tree)")]),e._v(" "),a("p",[e._v("레벨에 노드가 포화상태로 차 있는 이진 트리")]),e._v(" "),a("ol",[a("li",[e._v("최대의 노드 개수인 2^(h+1)-1인 노드를 가진 이진 트리")]),e._v(" "),a("li",[e._v("루트를 1번으로 하여 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐")])]),e._v(" "),a("h4",{attrs:{id:"완전-이진-트리-complete-binary-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#완전-이진-트리-complete-binary-tree"}},[e._v("#")]),e._v(" 완전 이진 트리(Complete binary Tree)")]),e._v(" "),a("p",[e._v("높이가 h이고 노드 수가 n개일 때 (단, 2^h ≤ n ≤ 2^(h+1)-1 ), Full 이진 트리의 노드 번호 1번 부터 n번 까지 빈 자리가 없는 이진 트리")]),e._v(" "),a("h4",{attrs:{id:"편향-이진-트리-skewed-binary-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#편향-이진-트리-skewed-binary-tree"}},[e._v("#")]),e._v(" 편향 이진 트리(Skewed binary Tree)")]),e._v(" "),a("p",[e._v("높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리")]),e._v(" "),a("h3",{attrs:{id:"binary-tree-순회-traversal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-tree-순회-traversal"}},[e._v("#")]),e._v(" Binary Tree - 순회(traversal)")]),e._v(" "),a("p",[e._v("트리의 각 노드를 중복되지 않게 전부 방문(Visit) 하는 것을 말하는데, 트리는 비선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없음")]),e._v(" "),a("h3",{attrs:{id:"_3가지의-기본적인-순회방법"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3가지의-기본적인-순회방법"}},[e._v("#")]),e._v(" 3가지의 기본적인 순회방법")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("        루트(V)\n        /    \\\n       /      \\\n왼쪽 서브트리  오른쪽 서브트리\n    (L)        (R)\n\n1. 전위 순회(Preorder traversal)\n    - VLR\n    - 자손노드보다 루트노드를 먼저 방문\n\n2. 중위 순회(Inorder traversal)\n    - LVR\n    - 왼쪽 자손, 루트, 오른쪽 자손 순으로 방문\n\n3. 후위 순회(Postorder traversal)\n    - LRV\n    - 루트노드보다 자손을 먼저 방문\n")])])]),a("h3",{attrs:{id:"전위-순회-preorder-traversal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#전위-순회-preorder-traversal"}},[e._v("#")]),e._v(" 전위 순회(Preorder traversal)")]),e._v(" "),a("ol",[a("li",[e._v("현재 노드 n을 방문하여 처리: V")]),e._v(" "),a("li",[e._v("현재 노드 n의 왼쪽 서브트리로 이동: L")]),e._v(" "),a("li",[e._v("현재 노드 n의 오른쪽 서브트리로 이동: R")])]),e._v(" "),a("h4",{attrs:{id:"ex-전위-순회-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-전위-순회-예제"}},[e._v("#")]),e._v(" ex) 전위 순회 예제")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("def preorder_traverse(T): # 전위순회\n    if T: # T is not None\n        visit(T) # print(T.item)\n        preorder_traverse(T.left)\n        preorder_traverse(T.right) # 재귀호출\n")])])]),a("h3",{attrs:{id:"중위-순회-inorder-traversal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#중위-순회-inorder-traversal"}},[e._v("#")]),e._v(" 중위 순회(Inorder traversal)")]),e._v(" "),a("ol",[a("li",[e._v("현재 노드 n의 왼쪽 서브트리로 이동: L")]),e._v(" "),a("li",[e._v("현재 노드 n을 방문하여 처리: V")]),e._v(" "),a("li",[e._v("현재 노드 n의 오른쪽 서브트리로 이동: R")])]),e._v(" "),a("h4",{attrs:{id:"ex-중위-순회-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-중위-순회-예제"}},[e._v("#")]),e._v(" ex) 중위 순회 예제")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("def inorder_traverse(T): # 중위순회\n    if T: # T is not None\n        inorder_traverse(T.left)\n        visit(T) # print(T.item)\n        inorder_traverse(T.right) # 재귀호출\n")])])]),a("h3",{attrs:{id:"후위-순회-postorder-traversal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#후위-순회-postorder-traversal"}},[e._v("#")]),e._v(" 후위 순회(Postorder traversal)")]),e._v(" "),a("ol",[a("li",[e._v("현재 노드 n의 왼쪽 서브트리로 이동: L")]),e._v(" "),a("li",[e._v("현재 노드 n의 오른쪽 서브트리로 이동: R")]),e._v(" "),a("li",[e._v("현재 노드 n을 방문하여 처리: V")])]),e._v(" "),a("h4",{attrs:{id:"ex-후위-순회-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-후위-순회-예제"}},[e._v("#")]),e._v(" ex) 후위 순회 예제")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("def postorder_traverse(T): # 후위순회\n    if T:\n        postorder_traverse(T.left)\n        postorder_traverse(T.right) # 재귀호출\n        visit(T) # print(T.item)\n")])])]),a("br"),e._v(" "),a("h2",{attrs:{id:"_3-expression-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-expression-tree"}},[e._v("#")]),e._v(" 3. Expression Tree")]),e._v(" "),a("h3",{attrs:{id:"list를-이용한-binary-tree의-표현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#list를-이용한-binary-tree의-표현"}},[e._v("#")]),e._v(" List를 이용한 Binary Tree의 표현")]),e._v(" "),a("ol",[a("li",[e._v("이진 트리에 각 노드 번호를 다음과 같이 부여")]),e._v(" "),a("li",[e._v("루트의 번호를 1로 함")]),e._v(" "),a("li",[e._v("레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2부터 2^(n+1)-1까지 번호를 차례로 부여")])]),e._v(" "),a("h3",{attrs:{id:"이진-트리의-노드-번호의-성질"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#이진-트리의-노드-번호의-성질"}},[e._v("#")]),e._v(" 이진 트리의 노드 번호의 성질")]),e._v(" "),a("ul",[a("li",[e._v("노드 번호가 i인 노드의 부모 노드 번호?\n*"),a("code",[e._v("i/2의 소수점 버림")])]),e._v(" "),a("li",[e._v("노드 번호가 i인 노드의 왼쪽 자식 노드 번호?\n*"),a("code",[e._v("2*i")])]),e._v(" "),a("li",[e._v("노드 번호가 i인 노드의 오른쪽 자식 노드 번호?\n*"),a("code",[e._v("2*i+1")])])]),e._v(" "),a("ul",[a("li",[e._v("노드 번호를 리스트의 인덱스로 사용")]),e._v(" "),a("li",[e._v("높이가 h인 이진 트리를 위한 리스트의 크기는\n"),a("ul",[a("li",[e._v("레벨 i의 최대 노드 수는? 2^i")]),e._v(" "),a("li",[e._v("따라서 1 + 2 + 4 + 8 + ... + 2^i = 2^(h+1)-1")])])])]),e._v(" "),a("h3",{attrs:{id:"리스트를-이용한-이진-트리-표현의-단점"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#리스트를-이용한-이진-트리-표현의-단점"}},[e._v("#")]),e._v(" 리스트를 이용한 이진 트리 표현의 단점")]),e._v(" "),a("p",[e._v("편향 이진 트리의 경우에 사용하지 않는 리스트 원소에 대한 메모리 공간 낭비 발생")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("연결 리스트를 이용하여 트리를 표현")]),e._v(" "),a("ul",[a("li",[e._v("리스트를 이용한 이진 트리 표현의 단점 보완")])])]),e._v(" "),a("li",[a("p",[e._v("연결 자료구조를 이용한 이진 트리의 이해와 표현")]),e._v(" "),a("ul",[a("li",[e._v("이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 List 노드를 사용하여 구현")])])])]),e._v(" "),a("h4",{attrs:{id:"ex-연결-리스트를-이용하여-트리를-표현한-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-연결-리스트를-이용하여-트리를-표현한-예제"}},[e._v("#")]),e._v(" ex) 연결 리스트를 이용하여 트리를 표현한 예제")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("----------------------------\n  left  |  데이터  |  right \n----------------------------\n왼쪽 자식노드       오른쪽 자식노드\n")])])]),a("br"),e._v(" "),a("h2",{attrs:{id:"_4-binary-search-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-binary-search-tree"}},[e._v("#")]),e._v(" 4. Binary Search Tree")]),e._v(" "),a("h3",{attrs:{id:"binary-search-tree의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-tree의-특징"}},[e._v("#")]),e._v(" Binary Search Tree의 특징")]),e._v(" "),a("ol",[a("li",[e._v("탐색작업을 효율적으로 하기 위한 자료구조")]),e._v(" "),a("li",[e._v("모든 원소는 서로 다른 유일한 키를 가짐")]),e._v(" "),a("li",[e._v("key(왼쪽 서브트리) < key(루트 노드) < key(오른쪽 서브트리)")]),e._v(" "),a("li",[e._v("왼쪽 서브트리와 오른쪽 서브트리라도 이진 탐색 트리임")]),e._v(" "),a("li",[e._v("중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음")])]),e._v(" "),a("h3",{attrs:{id:"binary-search-tree의-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-tree의-연산"}},[e._v("#")]),e._v(" Binary Search Tree의 연산")]),e._v(" "),a("h4",{attrs:{id:"탐색-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#탐색-연산"}},[e._v("#")]),e._v(" 탐색 연산")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("루트에서 시작")])]),e._v(" "),a("li",[a("p",[e._v("탐색할 키 값 x를 루트 노드의 키 값과 비교")])])]),e._v(" "),a("ul",[a("li",[e._v("키값 x = 루트 노드의 키값: 원하는 원소를 찾았으므로 탐색 연산 성공")]),e._v(" "),a("li",[e._v("키값 x < 루트 노드의 키값: 루트 노드의 왼쪽 서브트리에 대해서 탐색 연산 수행")]),e._v(" "),a("li",[e._v("키값 x > 루트 노드의 키값: 루트 노드의 오른쪽 서브트리에 대해서 탐색 연산 수행")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("서브트리에 대해서 순환적으로 탐색 연산을 반복")])]),e._v(" "),a("h4",{attrs:{id:"삽입-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#삽입-연산"}},[e._v("#")]),e._v(" 삽입 연산")]),e._v(" "),a("ol",[a("li",[e._v("먼저 탐색 연산을 수행")])]),e._v(" "),a("ul",[a("li",[e._v("삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인")]),e._v(" "),a("li",[e._v("탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 됨")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("탐색 실패한 위치에 원소를 삽입")])]),e._v(" "),a("h3",{attrs:{id:"binary-search-tree의-성능"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#binary-search-tree의-성능"}},[e._v("#")]),e._v(" Binary Search Tree의 성능")]),e._v(" "),a("ol",[a("li",[e._v("탐색(Searching), 삽입(Insertion), 삭제(Deletion) 시간은 트리의 높이에 좌우 됨")])]),e._v(" "),a("ul",[a("li",[e._v("O(h), h: BST의 깊이(height)")])]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("평균의 경우")])]),e._v(" "),a("ul",[a("li",[e._v("이진 트리가 균형적으로 생성되어 있는 경우")]),e._v(" "),a("li",[e._v("O(logn)")])]),e._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[e._v("최악의 경우")])]),e._v(" "),a("ul",[a("li",[e._v("한쪽으로 치우친 경사 이진 트리의 경우")]),e._v(" "),a("li",[e._v("O(n)")]),e._v(" "),a("li",[e._v("순차탐색과 시간복잡도가 같음")])]),e._v(" "),a("h3",{attrs:{id:"검색-알고리즘의-비교"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#검색-알고리즘의-비교"}},[e._v("#")]),e._v(" 검색 알고리즘의 비교")]),e._v(" "),a("ol",[a("li",[e._v("리스트에서의 순차 검색: O(n)")]),e._v(" "),a("li",[e._v("정렬된 리스트에서의 순차 검색: O(n)")]),e._v(" "),a("li",[e._v("정렬된 리스트에서의 이진 검색: O(logn)")]),e._v(" "),a("li",[e._v("이진 탐색 트리에서의 평균: O(logn)")])]),e._v(" "),a("ul",[a("li",[e._v("최악의 경우: O(n)")]),e._v(" "),a("li",[e._v("완전 이진 트리 또는 균형 트리로 바꿀 수 있다면 최악의 경우를 없앨 수 있음\n"),a("ul",[a("li",[e._v("새로운 원소를 삽입할 때 삽입 시간을 줄임")]),e._v(" "),a("li",[e._v("평균과 최악의 시간이 같음 O(logn)")])])])]),e._v(" "),a("ol",{attrs:{start:"5"}},[a("li",[e._v("해쉬 검색: O(1)")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_5-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-heap"}},[e._v("#")]),e._v(" 5. Heap")]),e._v(" "),a("h3",{attrs:{id:"heap의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heap의-특징"}},[e._v("#")]),e._v(" Heap의 특징")]),e._v(" "),a("p",[a("code",[e._v("완전 이진 트리에 있는 노드")]),e._v(" 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조")]),e._v(" "),a("ul",[a("li",[a("p",[a("code",[e._v("최대 힙(Max heap)")])]),e._v(" "),a("ul",[a("li",[e._v("키 값이 "),a("code",[e._v("가장 큰 노드를 찾기 위한 완전 이진 트리")])]),e._v(" "),a("li",[e._v("부모 노드의 키값 > 자식 노드의 키값")]),e._v(" "),a("li",[e._v("루트 노드: 키값이 가장 큰 노드")])])]),e._v(" "),a("li",[a("p",[a("code",[e._v("최소 힙(Min heap)")])]),e._v(" "),a("ul",[a("li",[e._v("키 값이 "),a("code",[e._v("가장 작은 노드를 찾기 위한 완전 이진 트리")])]),e._v(" "),a("li",[e._v("부모 노드의 키값 < 자식 노드의 키값")]),e._v(" "),a("li",[e._v("루트 노드: 키값이 가장 작은 노드")])])])]),e._v(" "),a("h3",{attrs:{id:"heap의-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heap의-연산"}},[e._v("#")]),e._v(" Heap의 연산")]),e._v(" "),a("h4",{attrs:{id:"삽입-연산-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#삽입-연산-2"}},[e._v("#")]),e._v(" 삽입 연산")]),e._v(" "),a("ol",[a("li",[e._v("삽입 전의 힙")]),e._v(" "),a("li",[e._v("삽입 할 자리 확장")]),e._v(" "),a("li",[e._v("확장한 자리에 삽입할 원소 저장")])]),e._v(" "),a("h4",{attrs:{id:"삭제-연산"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#삭제-연산"}},[e._v("#")]),e._v(" 삭제 연산")]),e._v(" "),a("ol",[a("li",[e._v("힙에서는 "),a("code",[e._v("루트 노드의 원소만을 삭제")]),e._v("할 수 있음")]),e._v(" "),a("li",[e._v("루트 노드의 원소만을 삭제하여 반환")]),e._v(" "),a("li",[e._v("힙의 종류에 따라 "),a("code",[e._v("최대값 또는 최소값")]),e._v("을 구할 수 있음")])]),e._v(" "),a("ul",[a("li",[e._v("이를 이용하여 우선순위 큐를 힙으로 구현할 수 있음")])]),e._v(" "),a("h4",{attrs:{id:"ex-힙에서의-삭제-연산-예제"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-힙에서의-삭제-연산-예제"}},[e._v("#")]),e._v(" ex) 힙에서의 삭제 연산 예제")]),e._v(" "),a("ol",[a("li",[e._v("루트 노드의 원소 삭제")]),e._v(" "),a("li",[e._v("마지막 노드를 루트 노드 위치로 이동")]),e._v(" "),a("li",[e._v("삽입노드와 자식노드를 비교하여 자리 바꾸기")]),e._v(" "),a("li",[e._v("자리 확정")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"reference-additional-resources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[e._v("#")]),e._v(" Reference & Additional Resources")]),e._v(" "),a("blockquote",[a("p",[e._v("SW Expert Academy")])])])}),[],!1,null,null,null);r.default=v.exports}}]);