<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>완전 검색 | Today Sohyeon Learned💡</title>
    <meta name="description" content="Personal Wiki (Today I Learned)">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/TIL/images/logo-144.png">
  <link rel="manifest" href="/TIL/manifest.json">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.67ceecaa.css" as="style"><link rel="preload" href="/TIL/assets/js/app.22664d50.js" as="script"><link rel="preload" href="/TIL/assets/js/2.170f2245.js" as="script"><link rel="preload" href="/TIL/assets/js/18.d2aded4a.js" as="script"><link rel="preload" href="/TIL/assets/js/4.22de8c0b.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.53565a86.js"><link rel="prefetch" href="/TIL/assets/js/11.dd38a3d1.js"><link rel="prefetch" href="/TIL/assets/js/12.8a15d59c.js"><link rel="prefetch" href="/TIL/assets/js/13.3aa8ecf1.js"><link rel="prefetch" href="/TIL/assets/js/14.4562d4b0.js"><link rel="prefetch" href="/TIL/assets/js/15.a722222c.js"><link rel="prefetch" href="/TIL/assets/js/16.605b62a4.js"><link rel="prefetch" href="/TIL/assets/js/17.faaf01fd.js"><link rel="prefetch" href="/TIL/assets/js/19.727c9058.js"><link rel="prefetch" href="/TIL/assets/js/20.bfeeb12b.js"><link rel="prefetch" href="/TIL/assets/js/21.c141afee.js"><link rel="prefetch" href="/TIL/assets/js/3.2f42b2e3.js"><link rel="prefetch" href="/TIL/assets/js/5.c3928ba2.js"><link rel="prefetch" href="/TIL/assets/js/6.7bda8340.js"><link rel="prefetch" href="/TIL/assets/js/7.5699ad9f.js"><link rel="prefetch" href="/TIL/assets/js/8.5ef90a7f.js"><link rel="prefetch" href="/TIL/assets/js/9.7c14c0ad.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.67ceecaa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today Sohyeon Learned💡</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>🎯 목표</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>📒 SWEA</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/SWEA/1-1. List1.html" class="sidebar-link">List1</a></li><li><a href="/TIL/SWEA/1-2. List2.html" class="sidebar-link">List2</a></li><li><a href="/TIL/SWEA/1-3. String.html" class="sidebar-link">String</a></li><li><a href="/TIL/SWEA/1-4. Stack1.html" class="sidebar-link">Stack1</a></li><li><a href="/TIL/SWEA/1-5. Stack2.html" class="sidebar-link">Stack2</a></li><li><a href="/TIL/SWEA/1-6. Queue.html" class="sidebar-link">Queue</a></li><li><a href="/TIL/SWEA/1-7. Linked List.html" class="sidebar-link">Linked List</a></li><li><a href="/TIL/SWEA/1-8. Tree.html" class="sidebar-link">Tree</a></li><li><a href="/TIL/SWEA/1-9. 시작하기.html" class="sidebar-link">시작하기</a></li><li><a href="/TIL/SWEA/2-1. 완전 검색.html" class="active sidebar-link">완전 검색</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/SWEA/2-1. 완전 검색.html#_1-완전-검색-기법" class="sidebar-link">1. 완전 검색 기법</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/2-1. 완전 검색.html#_2-조합적-문제" class="sidebar-link">2. 조합적 문제</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/2-1. 완전 검색.html#reference-additional-resources" class="sidebar-link">Reference &amp; Additional Resources</a></li></ul></li><li><a href="/TIL/SWEA/2-2. 탐욕 알고리즘.html" class="sidebar-link">탐욕 알고리즘</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="완전-검색"><a href="#완전-검색" class="header-anchor">#</a> 완전 검색</h1> <p><em>written by sohyeon</em>🍀</p> <br> <h2 id="_1-완전-검색-기법"><a href="#_1-완전-검색-기법" class="header-anchor">#</a> 1. 완전 검색 기법</h2> <h3 id="베이비진-baby-gin"><a href="#베이비진-baby-gin" class="header-anchor">#</a> 베이비진(Baby-Gin)</h3> <div class="language- extra-class"><pre class="language-text"><code>1. 0~9 사이의 숫자 카드에서 `임의의 카드 6장 뽑음`
1-1. 3장의 카드가 연속적인 번호를 갖는 경우 런(Run)
1-2. 3장의 카드가 동일한 번호를 갖는 경우 트리플릿(Triplete)
2. 6장의 카드가 Run과 Triplet로만 구성된 경우를 Baby-Gin으로 부름
</code></pre></div><h3 id="완전-검색-2"><a href="#완전-검색-2" class="header-anchor">#</a> 완전 검색</h3> <ul><li>문제의 해를 얻기 위해 <code>가능한 모든 경우들을 나열해 보고 확인</code>하는 기법
<ul><li>고지식한 방법(Brute-force), 생성 및 테스트(Generate and test)</li> <li>Brute-force의 force의 의미는 사람보다는 컴퓨터의 힘을 의미</li></ul></li> <li>문제를 해결하기 위한 간단하고 쉬운 접근법
<ul><li>상대적으로 빠른 시간에 문제 해결(알고리즘 설계) 가능</li></ul></li> <li>대부분의 문제에 적용 가능</li> <li>문제에 포함된 자료(요소, 인스턴스)의 크기가 작을 경우 유용</li></ul> <h3 id="고지식한-검색-순차-검색-sequential-search"><a href="#고지식한-검색-순차-검색-sequential-search" class="header-anchor">#</a> 고지식한 검색 (순차 검색, Sequential Search)</h3> <p>자료들의 리스트에서 키 값을 찾기 위해 첫 번째 자료부터 비교하면서 진행</p> <h4 id="정렬되지-않는-자료의-예제"><a href="#정렬되지-않는-자료의-예제" class="header-anchor">#</a> 정렬되지 않는 자료의 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>def sequentialSearch(a,n,key):
    i = 0
    while i &lt; n and a[i] != key:
        i = i + 1

    if i &lt; n: 
        return i # 성공하면 키 값의 인덱스 값 반환
    else: 
        return -1 # 실패하면 -1 반환
</code></pre></div><ul><li>순차 검색에서 <code>리스트에 키 값이 존재하지 않는다는 것</code>을 확신하기 위해서는 <code>모든 자료들에 대해 키 값과 비교 작업 수행</code></li></ul> <h3 id="완전-검색으로-시작하기"><a href="#완전-검색으로-시작하기" class="header-anchor">#</a> 완전 검색으로 시작하기</h3> <ul><li>문제 해결을 위한 가장 단순한 방법이기 때문에 <code>문제의 크기가 커지면 시간 복잡도가 매우 크게 증가</code></li> <li>모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적음
<ul><li>완전 검색을 통해 <code>입력의 크기를 작게 해서 빠르게 답을 구하는 알고리즘 설계</code></li></ul></li> <li>그리디 기법이나 동적 계획법을 이용해서 효율적인 알고리즘을 찾음</li> <li>주어진 문제를 해결하는 방법
<ul><li>완전 검색으로 접근하여 해답 도출</li> <li>성능 개설을 위해 다른 알고리즘 사용</li> <li>해답 확인</li></ul></li></ul> <h4 id="ex-완전-검색을-통한-baby-gin-접근"><a href="#ex-완전-검색을-통한-baby-gin-접근" class="header-anchor">#</a> ex) 완전 검색을 통한 Baby-gin 접근</h4> <div class="language- extra-class"><pre class="language-text"><code>1. 고려할 수 있는 모든 경우의 수 생성하기
    &gt; 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
2. 해답 테스트하기
    &gt; 앞의 3자리와 뒤의 3자리를 잘라, run와 triplete 여부를 테스트하고 최종적으로 Baby-gin을 판단함
    &gt; 단순히 순열 생성 시 중복된 작업 수행
    &gt; 중복을 제거할 수 있다면 계산 시간 단축 가능
</code></pre></div><br> <h2 id="_2-조합적-문제"><a href="#_2-조합적-문제" class="header-anchor">#</a> 2. 조합적 문제</h2> <h3 id="완전-검색-3"><a href="#완전-검색-3" class="header-anchor">#</a> 완전 검색</h3> <ul><li>많은 종류의 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 검색</li> <li>순열(Permutation), 조합(Combination), 부분집합(Subset)과 같은 조합적 문제(Combinatorial Problems)와 관련</li> <li>조합적 문제에 대한 <code>고지식한 방법(Brute-force)</code></li></ul> <h3 id="순열-permutation"><a href="#순열-permutation" class="header-anchor">#</a> 순열(Permutation)</h3> <p>서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것</p> <ul><li>서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현 : <code>nPr</code></li> <li>nPr은 다음과 같은 식이 성립 : <code>nPr = n * (n-1) * (n-2) * ... * (n-r+1)</code></li></ul> <h4 id="순열과-관련된-다수의-알고리즘-문제들"><a href="#순열과-관련된-다수의-알고리즘-문제들" class="header-anchor">#</a> 순열과 관련된 다수의 알고리즘 문제들</h4> <ul><li>순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련됨
<ul><li>순회 외판원 문제(Traveling Salesman Problem)
<ul><li>여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어짐</li> <li>출발 도시에서 시작해서 다른 모든 도시들을 단 한 번만 방문하고 출발</li> <li>방문할 도시들을 순서대로 나열하면 하나의 경로가 됨</li></ul></li></ul></li></ul> <h4 id="ex-1-2-3-로-순열-생성"><a href="#ex-1-2-3-로-순열-생성" class="header-anchor">#</a> ex) {1, 2, 3} 로 순열 생성</h4> <p>동일한 숫자가 포함되지 않았을 때, 각 자릿수 별로 loop을 이용</p> <div class="language- extra-class"><pre class="language-text"><code>for i in range(1,4):
    for j in range(1,4):
        if j != i: # 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 for loop를 이용해서 구현
            for k in range(1,4):
                if k != i and k != j:
                    print(i, j, k)
</code></pre></div><ul><li>Baby-Gin을 판별하는 프로그램은 여섯 개의 for loop를 중첩해서 <code>모든 순열을 만들어 냄</code></li> <li>일반적으로 <code>재귀 호출을 이용</code>해서 필요한 횟수만큼 반복을 수행하면서 수열 생성</li></ul> <h3 id="순열을-만드는-방법"><a href="#순열을-만드는-방법" class="header-anchor">#</a> 순열을 만드는 방법</h3> <ul><li>사전식 순서
<ul><li>요소들이 오름차순으로 나열된 형태가 시작하는 하나의 순열</li></ul></li> <li>최소 변경을 통한 방법
<ul><li>각각의 순열들은 이전의 상태에서 단지 두 개의 요소들 교환을 통해 생성</li> <li>{1, 2, 3} 순열에서 1과 3을 교환해서 {3, 2, 1} 순열을 만듦</li></ul></li></ul> <h4 id="최소한의-변경-minimum-change-requirement-을-통해-순열을-생성하는-방법"><a href="#최소한의-변경-minimum-change-requirement-을-통해-순열을-생성하는-방법" class="header-anchor">#</a> 최소한의 변경(Minimum-change requirement)을 통해 순열을 생성하는 방법</h4> <ul><li>Johnson-Trotter 알고리즘
<ul><li>각 선들 =&gt; 네 개의 요소에 대응되고 점이 표시괸 선이 교환되는 요소</li></ul></li> <li>1950년대의 교회의 종소리 패턴하고 유사</li></ul> <div class="language- extra-class"><pre class="language-text"><code>-------------------------------------------------
  |     |     |   |     |     |   |     |     |  
-------------------------------------------------
    |       |       |       |       |       |  
-------------------------------------------------
      |   |     |     |   |     |     |   |     
-------------------------------------------------
</code></pre></div><h4 id="두-원소의-교환을-통해-생성"><a href="#두-원소의-교환을-통해-생성" class="header-anchor">#</a> 두 원소의 교환을 통해 생성</h4> <ul><li>N개의 요소가 있을 때 N번의 선택으로 순열 생성</li> <li>순열이 생성되는 모든 과정을 그리면 <code>트리 구조</code>를 가짐
<ul><li>요소의 수가 네 개로 루트는 자식이 네 개이고 트리의 높이가 1인 내부노드들은 자식이 세 개가 되는 구조의 트리가 됨</li> <li>네 번의 선택을 하기 때문에 트리의 높이는 4가 됨</li> <li>트리를 순회하는 것과 같이 재귀 호출을 통해 순열을 생성</li> <li>트리의 단말에 도착하게 되면 하나의 순열 생성</li></ul></li></ul> <h4 id="ex-재귀-호출을-통한-순열-생성-예제"><a href="#ex-재귀-호출을-통한-순열-생성-예제" class="header-anchor">#</a> ex) 재귀 호출을 통한 순열 생성 예제</h4> <div class="language- extra-class"><pre class="language-text"><code># a[]: 데이터가 저장된 리스트
# n: 원소의 개수, k: 현재까지 선택된 원소의 수

def perm(n, k):
    if k == n:   # 하나의 순열이 생성됨
        print(a) # 원하는 작업 수행
    else:
        for i in range(k, n):
            a[k], a[i] = a[i], a[k] # 교환을 통한 선택
            perm(n, k+1)            # 재귀호출
            a[k], a[i] = a[i], a[k] # 이전 상태로 복귀
</code></pre></div><h4 id="ex-파이썬의-라이브러리를-활용한-순열"><a href="#ex-파이썬의-라이브러리를-활용한-순열" class="header-anchor">#</a> ex) 파이썬의 라이브러리를 활용한 순열</h4> <div class="language- extra-class"><pre class="language-text"><code>import itertools

mylist = [1,2,3]
result = itertools.permutations(mylist) # (mylist, 3), r 생략시 기본값 리스트 크기

print(list(result))

# 결과값: [(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]

</code></pre></div><h4 id="ex-파이썬의-라이브러리를-활용한-중복순열"><a href="#ex-파이썬의-라이브러리를-활용한-중복순열" class="header-anchor">#</a> ex) 파이썬의 라이브러리를 활용한 중복순열</h4> <div class="language- extra-class"><pre class="language-text"><code>import itertools

mylist = [1,2,3]
result = itertools.product(mylist, repeat=3)

print(list(result))

# 결과값: [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 2, 1), (1, 2, 2), (1, 2, 3), (1, 3, 1), (1, 3, 2), (1, 3, 3), (2, 1, 1), (2, 1, 2), (2, 1, 3), (2, 2, 1), (2, 2, 2), (2, 2, 3), (2, 3, 1), (2, 3, 2), (2, 3, 3), (3, 1, 1), (3, 1, 2), (3, 1, 3), (3, 2, 1), (3, 2, 2), (3, 2, 3), (3, 3, 1), (3, 3, 2), (3, 3, 3)]

</code></pre></div><h3 id="부분집합"><a href="#부분집합" class="header-anchor">#</a> 부분집합</h3> <ul><li>집합에 포함된 원소들을 선택하는 것</li> <li>다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분 집합을 찾는 것</li> <li>ex) 배낭 짐싸기(Knapsack problem)
<ul><li>배낭과 물건들의 집합이 주어지며, 배낭은 무게가 있고 아이템들은 각가 무게와 가치가 있음</li> <li>배낭에 담는 무게의 총합 &lt; 배낭의 무게</li> <li>물건의 총합이 배낭의 무게를 초과하지 않으면서 가치의 합이 최대가 되는 물건들을 선택하는 문제</li></ul></li> <li>N개의 원소를 포함한 집합
<ul><li>자기 자신과 공집합 포함한 <code>모든 부분집합(Power set)의 개수는 2^n개</code></li></ul></li></ul> <h4 id="ex-단순하게-모든-부분-집합을-생성하는-예제"><a href="#ex-단순하게-모든-부분-집합을-생성하는-예제" class="header-anchor">#</a> ex) 단순하게 모든 부분 집합을 생성하는 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>arr = [2,3,4,5] # 실제 집합
bit = [0] * len(arr)

for i in range(2):
    bit[0] = i                 # 0번째 원소
    for j in range(2):
        bit[1] = j             # 1번째 원소
        for k in range(2):
            bit[2] = k         # 2번째 원소
            for l in range(2):
                bit[3] = l     # 3번째 원소
                print([arr[x] for x in range(len(bit)) if bit[x]])  # 생성된 부분집합을 출력
</code></pre></div><h3 id="바이너리-카운팅-binary-counting"><a href="#바이너리-카운팅-binary-counting" class="header-anchor">#</a> 바이너리 카운팅(Binary Counting)</h3> <ul><li>비트표현을 이용해서 부분집합을 생성하는 방법</li> <li>원소 수에 해당하는 N개의 비트 열을 이용</li> <li>i 번째 비트 값이 1이면 i 번째 원소가 포함되었음을 의미 ( i 는 인덱스 )</li></ul> <h4 id="ex-바이너리-카운팅을-통한-부분집합-생성하는-예제"><a href="#ex-바이너리-카운팅을-통한-부분집합-생성하는-예제" class="header-anchor">#</a> ex) 바이너리 카운팅을 통한 부분집합 생성하는 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>arr = [2,3,4,5]
n = len(arr) # n : 원소의 개수

for i in range(1&lt;&lt;n):   # 1&lt;&lt;n : 부분 집합의 개수
    for j in range(n):  # 원소의 수만큼 비트를 비교함
        if i &amp; (1&lt;&lt;j):  # i의 j번째 비트가 1이면 j번째 원소 출력  
            print(arr[j], end=&quot;,&quot;)
        print()
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code># 리스트의 함축을 이용한 코드

arr = [2,3,4,5]

for i in range(1&lt;&lt;len(arr)):
    print([arr[j] for j in range(len(arr)) if i &amp; (1&lt;&lt;j)])
</code></pre></div><h3 id="조합"><a href="#조합" class="header-anchor">#</a> 조합</h3> <ul><li>서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것</li> <li>조합의 수식
<ul><li><code>nCr = n!/[(n-r)!r!]</code></li> <li><code>nC0 = 1, nCn = 1</code></li> <li><code>nCr = nC(n-r)</code></li> <li><code>nCr = (n-1)C(r-1) + (n-1)Cr</code></li></ul></li> <li>재귀적 정의의 표현
<ul><li>5C3 = 4C2 + 4C3</li> <li>다섯 개에서 세 개를 선택하는 모든 경우
<ul><li>5가 포함되는 경우 &amp; 5가 포함되지 않는 경우</li> <li><code>5C3</code>은 5를 포함한 <code>4C2의 경우의 수</code>와 5를 제외한 <code>4C3의 경우의 수를 합</code>한 것과 같음</li></ul></li></ul></li></ul> <h4 id="ex-재귀-호출을-이용한-조합-생성-알고리즘"><a href="#ex-재귀-호출을-이용한-조합-생성-알고리즘" class="header-anchor">#</a> ex) 재귀 호출을 이용한 조합 생성 알고리즘</h4> <div class="language- extra-class"><pre class="language-text"><code># an[] : n개의 원소를 가지고 있는 리스트
# tr[] : 조합이 임시 저장될 r개의 크기의 리스트

def comb(n, r):
    if r == 0: print(tr)
    elif n &lt; r: return
    else:
        tr[r-1] = an[n-1]
        comb(n-1, r-1)
        comb(n-1, r)
</code></pre></div><h4 id="ex-파이썬의-라이브러리를-활용한-조합"><a href="#ex-파이썬의-라이브러리를-활용한-조합" class="header-anchor">#</a> ex) 파이썬의 라이브러리를 활용한 조합</h4> <div class="language- extra-class"><pre class="language-text"><code>import itertools

mylist = [1,2,3]
result = itertools.combinations(mylist, r=2) # r 생략불가
print(list(result))
</code></pre></div><h4 id="ex-파이썬의-라이브러리를-활용한-중복조합"><a href="#ex-파이썬의-라이브러리를-활용한-중복조합" class="header-anchor">#</a> ex) 파이썬의 라이브러리를 활용한 중복조합</h4> <div class="language- extra-class"><pre class="language-text"><code>import itertools

mylist = [1,2,3]
result = itertools.combinations_with_replacement(mylist, r=2) # r 생략불가
print(list(result))
</code></pre></div><br> <h2 id="reference-additional-resources"><a href="#reference-additional-resources" class="header-anchor">#</a> Reference &amp; Additional Resources</h2> <blockquote><p>SW Expert Academy</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/9/2020, 2:49:47 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/TIL/SWEA/1-9. 시작하기.html" class="prev">
        시작하기
      </a></span> <span class="next"><a href="/TIL/SWEA/2-2. 탐욕 알고리즘.html">
        탐욕 알고리즘
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/TIL/assets/js/app.22664d50.js" defer></script><script src="/TIL/assets/js/2.170f2245.js" defer></script><script src="/TIL/assets/js/18.d2aded4a.js" defer></script><script src="/TIL/assets/js/4.22de8c0b.js" defer></script>
  </body>
</html>
