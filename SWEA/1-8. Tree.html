<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Tree | Today Sohyeon Learned💡</title>
    <meta name="description" content="Personal Wiki (Today I Learned)">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/TIL/images/logo-144.png">
  <link rel="manifest" href="/TIL/manifest.json">
    
    <link rel="preload" href="/TIL/assets/css/0.styles.67ceecaa.css" as="style"><link rel="preload" href="/TIL/assets/js/app.6416d9a2.js" as="script"><link rel="preload" href="/TIL/assets/js/2.170f2245.js" as="script"><link rel="preload" href="/TIL/assets/js/16.605b62a4.js" as="script"><link rel="preload" href="/TIL/assets/js/4.22de8c0b.js" as="script"><link rel="prefetch" href="/TIL/assets/js/10.590f9974.js"><link rel="prefetch" href="/TIL/assets/js/11.23af623c.js"><link rel="prefetch" href="/TIL/assets/js/12.84782867.js"><link rel="prefetch" href="/TIL/assets/js/13.d8596608.js"><link rel="prefetch" href="/TIL/assets/js/14.fe551cbc.js"><link rel="prefetch" href="/TIL/assets/js/15.a722222c.js"><link rel="prefetch" href="/TIL/assets/js/17.faaf01fd.js"><link rel="prefetch" href="/TIL/assets/js/18.d2aded4a.js"><link rel="prefetch" href="/TIL/assets/js/19.393754e2.js"><link rel="prefetch" href="/TIL/assets/js/20.bfeeb12b.js"><link rel="prefetch" href="/TIL/assets/js/21.c141afee.js"><link rel="prefetch" href="/TIL/assets/js/3.2f42b2e3.js"><link rel="prefetch" href="/TIL/assets/js/5.c3928ba2.js"><link rel="prefetch" href="/TIL/assets/js/6.7bda8340.js"><link rel="prefetch" href="/TIL/assets/js/7.5699ad9f.js"><link rel="prefetch" href="/TIL/assets/js/8.5ef90a7f.js"><link rel="prefetch" href="/TIL/assets/js/9.ce50b17a.js">
    <link rel="stylesheet" href="/TIL/assets/css/0.styles.67ceecaa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/TIL/" class="home-link router-link-active"><!----> <span class="site-name">Today Sohyeon Learned💡</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/shjang1013/TIL" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>🎯 목표</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>📒 SWEA</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/TIL/SWEA/1-1. List1.html" class="sidebar-link">List1</a></li><li><a href="/TIL/SWEA/1-2. List2.html" class="sidebar-link">List2</a></li><li><a href="/TIL/SWEA/1-3. String.html" class="sidebar-link">String</a></li><li><a href="/TIL/SWEA/1-4. Stack1.html" class="sidebar-link">Stack1</a></li><li><a href="/TIL/SWEA/1-5. Stack2.html" class="sidebar-link">Stack2</a></li><li><a href="/TIL/SWEA/1-6. Queue.html" class="sidebar-link">Queue</a></li><li><a href="/TIL/SWEA/1-7. Linked List.html" class="sidebar-link">Linked List</a></li><li><a href="/TIL/SWEA/1-8. Tree.html" class="active sidebar-link">Tree</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#_1-tree의-특성" class="sidebar-link">1. Tree의 특성</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#_2-binary-tree의-특징" class="sidebar-link">2. Binary Tree의 특징</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#_3-expression-tree" class="sidebar-link">3. Expression Tree</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#_4-binary-search-tree" class="sidebar-link">4. Binary Search Tree</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#_5-heap" class="sidebar-link">5. Heap</a></li><li class="sidebar-sub-header"><a href="/TIL/SWEA/1-8. Tree.html#reference-additional-resources" class="sidebar-link">Reference &amp; Additional Resources</a></li></ul></li><li><a href="/TIL/SWEA/1-9. 시작하기.html" class="sidebar-link">시작하기</a></li><li><a href="/TIL/SWEA/2-1. 완전 검색.html" class="sidebar-link">완전 검색</a></li><li><a href="/TIL/SWEA/2-2. 탐욕 알고리즘.html" class="sidebar-link">탐욕 알고리즘</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="tree"><a href="#tree" class="header-anchor">#</a> Tree</h1> <p><em>written by sohyeon</em>🍀</p> <br> <h2 id="_1-tree의-특성"><a href="#_1-tree의-특성" class="header-anchor">#</a> 1. Tree의 특성</h2> <h3 id="tree의-개념"><a href="#tree의-개념" class="header-anchor">#</a> Tree의 개념</h3> <p>비선형 구조로 원소들 간에 1 : n 관계를 가지는 자료구조</p> <ol><li>원소들 간에 계층 관계를 가지는 계층형 자료구조</li> <li>상위 원소에서 하위 원소로 내려가면서 확장되는 <code>Tree(나무)모양의 구조</code></li></ol> <h3 id="tree의-특성"><a href="#tree의-특성" class="header-anchor">#</a> Tree의 특성</h3> <ol><li>한 개 이상의 노드로 이루어진 유한 집합</li></ol> <ul><li>루트(Root) : 노드 중 최상위 노드</li> <li>나머지 노드들: n개의 분리 집합 T1, ... ,TN으로 분리될 수 있음</li></ul> <ol start="2"><li>이들 T1, ... ,TN은 각각 하나의 트리가 되며(재귀적 정의) 루트의 <code>서브트리(SubTree)</code>라고 함</li></ol> <h3 id="tree의-구성요소"><a href="#tree의-구성요소" class="header-anchor">#</a> Tree의 구성요소</h3> <ul><li><code>노드(node)</code> <ul><li>트리의 원소</li></ul></li> <li><code>간선(edge)</code> <ul><li>노드를 연결하는 선</li> <li>부모 노드와 자식 노드를 연결</li></ul></li> <li><code>루트 노드(Root node)</code> <ul><li>트리의 시작 노드</li></ul></li> <li><code>형제 노드(Sibling node)</code> <ul><li>같은 부모 노드의 자식 노드들</li></ul></li> <li><code>조상 노드(Ancestor node)</code> <ul><li>간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들</li></ul></li> <li><code>서브트리(SubTree)</code> <ul><li>부모 노드와 연결된 간선을 끊었을 때 생성되는 트리</li></ul></li> <li><code>자손 노드(Descendent node)</code> <ul><li>서브트리에 있는 하위 레벨의 노드들</li></ul></li> <li><code>차수(degree)</code> <ul><li>노드의 연결된 자식 노드의 수</li> <li>트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값</li></ul></li> <li><code>단말 노드(리프 노드)</code> <ul><li>차수가 0인 노드</li> <li>자식 노드가 없는 노드</li></ul></li> <li><code>높이</code> <ul><li>노드의 높이: 노드의 레벨</li> <li>트리의 높이
<ul><li>트리에 있는 노드의 높이 중에서 가장 큰 값</li> <li>최대 레벨</li></ul></li></ul></li></ul> <br> <h2 id="_2-binary-tree의-특징"><a href="#_2-binary-tree의-특징" class="header-anchor">#</a> 2. Binary Tree의 특징</h2> <h3 id="binary-tree의-특징"><a href="#binary-tree의-특징" class="header-anchor">#</a> Binary Tree의 특징</h3> <ol><li>모든 노드들이 2개의 서브트리를 갖는 특별한 형태의 트리</li> <li>노드가 자식 노드를 최대한 2개까지만 가질 수 있는 트리</li> <li>레벨 i에서의 노드의 최대 개수는 2^i개</li> <li>높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개, 최대 개수는 2^(h+1)-1개가 됨</li></ol> <h3 id="binary-tree의-종류"><a href="#binary-tree의-종류" class="header-anchor">#</a> Binary Tree의 종류</h3> <h4 id="포화-이진-트리-full-binary-tree"><a href="#포화-이진-트리-full-binary-tree" class="header-anchor">#</a> 포화 이진 트리(Full binary Tree)</h4> <p>레벨에 노드가 포화상태로 차 있는 이진 트리</p> <ol><li>최대의 노드 개수인 2^(h+1)-1인 노드를 가진 이진 트리</li> <li>루트를 1번으로 하여 2^(h+1)-1까지 정해진 위치에 대한 노드 번호를 가짐</li></ol> <h4 id="완전-이진-트리-complete-binary-tree"><a href="#완전-이진-트리-complete-binary-tree" class="header-anchor">#</a> 완전 이진 트리(Complete binary Tree)</h4> <p>높이가 h이고 노드 수가 n개일 때 (단, 2^h ≤ n ≤ 2^(h+1)-1 ), Full 이진 트리의 노드 번호 1번 부터 n번 까지 빈 자리가 없는 이진 트리</p> <h4 id="편향-이진-트리-skewed-binary-tree"><a href="#편향-이진-트리-skewed-binary-tree" class="header-anchor">#</a> 편향 이진 트리(Skewed binary Tree)</h4> <p>높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드 만을 가진 이진 트리</p> <h3 id="binary-tree-순회-traversal"><a href="#binary-tree-순회-traversal" class="header-anchor">#</a> Binary Tree - 순회(traversal)</h3> <p>트리의 각 노드를 중복되지 않게 전부 방문(Visit) 하는 것을 말하는데, 트리는 비선형 구조이기 때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없음</p> <h3 id="_3가지의-기본적인-순회방법"><a href="#_3가지의-기본적인-순회방법" class="header-anchor">#</a> 3가지의 기본적인 순회방법</h3> <div class="language- extra-class"><pre class="language-text"><code>        루트(V)
        /    \
       /      \
왼쪽 서브트리  오른쪽 서브트리
    (L)        (R)

1. 전위 순회(Preorder traversal)
    - VLR
    - 자손노드보다 루트노드를 먼저 방문

2. 중위 순회(Inorder traversal)
    - LVR
    - 왼쪽 자손, 루트, 오른쪽 자손 순으로 방문

3. 후위 순회(Postorder traversal)
    - LRV
    - 루트노드보다 자손을 먼저 방문
</code></pre></div><h3 id="전위-순회-preorder-traversal"><a href="#전위-순회-preorder-traversal" class="header-anchor">#</a> 전위 순회(Preorder traversal)</h3> <ol><li>현재 노드 n을 방문하여 처리: V</li> <li>현재 노드 n의 왼쪽 서브트리로 이동: L</li> <li>현재 노드 n의 오른쪽 서브트리로 이동: R</li></ol> <h4 id="ex-전위-순회-예제"><a href="#ex-전위-순회-예제" class="header-anchor">#</a> ex) 전위 순회 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>def preorder_traverse(T): # 전위순회
    if T: # T is not None
        visit(T) # print(T.item)
        preorder_traverse(T.left)
        preorder_traverse(T.right) # 재귀호출
</code></pre></div><h3 id="중위-순회-inorder-traversal"><a href="#중위-순회-inorder-traversal" class="header-anchor">#</a> 중위 순회(Inorder traversal)</h3> <ol><li>현재 노드 n의 왼쪽 서브트리로 이동: L</li> <li>현재 노드 n을 방문하여 처리: V</li> <li>현재 노드 n의 오른쪽 서브트리로 이동: R</li></ol> <h4 id="ex-중위-순회-예제"><a href="#ex-중위-순회-예제" class="header-anchor">#</a> ex) 중위 순회 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>def inorder_traverse(T): # 중위순회
    if T: # T is not None
        inorder_traverse(T.left)
        visit(T) # print(T.item)
        inorder_traverse(T.right) # 재귀호출
</code></pre></div><h3 id="후위-순회-postorder-traversal"><a href="#후위-순회-postorder-traversal" class="header-anchor">#</a> 후위 순회(Postorder traversal)</h3> <ol><li>현재 노드 n의 왼쪽 서브트리로 이동: L</li> <li>현재 노드 n의 오른쪽 서브트리로 이동: R</li> <li>현재 노드 n을 방문하여 처리: V</li></ol> <h4 id="ex-후위-순회-예제"><a href="#ex-후위-순회-예제" class="header-anchor">#</a> ex) 후위 순회 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>def postorder_traverse(T): # 후위순회
    if T:
        postorder_traverse(T.left)
        postorder_traverse(T.right) # 재귀호출
        visit(T) # print(T.item)
</code></pre></div><br> <h2 id="_3-expression-tree"><a href="#_3-expression-tree" class="header-anchor">#</a> 3. Expression Tree</h2> <h3 id="list를-이용한-binary-tree의-표현"><a href="#list를-이용한-binary-tree의-표현" class="header-anchor">#</a> List를 이용한 Binary Tree의 표현</h3> <ol><li>이진 트리에 각 노드 번호를 다음과 같이 부여</li> <li>루트의 번호를 1로 함</li> <li>레벨 n에 있는 노드에 대하여 왼쪽부터 오른쪽으로 2부터 2^(n+1)-1까지 번호를 차례로 부여</li></ol> <h3 id="이진-트리의-노드-번호의-성질"><a href="#이진-트리의-노드-번호의-성질" class="header-anchor">#</a> 이진 트리의 노드 번호의 성질</h3> <ul><li>노드 번호가 i인 노드의 부모 노드 번호?
*<code>i/2의 소수점 버림</code></li> <li>노드 번호가 i인 노드의 왼쪽 자식 노드 번호?
*<code>2*i</code></li> <li>노드 번호가 i인 노드의 오른쪽 자식 노드 번호?
*<code>2*i+1</code></li></ul> <ul><li>노드 번호를 리스트의 인덱스로 사용</li> <li>높이가 h인 이진 트리를 위한 리스트의 크기는
<ul><li>레벨 i의 최대 노드 수는? 2^i</li> <li>따라서 1 + 2 + 4 + 8 + ... + 2^i = 2^(h+1)-1</li></ul></li></ul> <h3 id="리스트를-이용한-이진-트리-표현의-단점"><a href="#리스트를-이용한-이진-트리-표현의-단점" class="header-anchor">#</a> 리스트를 이용한 이진 트리 표현의 단점</h3> <p>편향 이진 트리의 경우에 사용하지 않는 리스트 원소에 대한 메모리 공간 낭비 발생</p> <ol><li><p>연결 리스트를 이용하여 트리를 표현</p> <ul><li>리스트를 이용한 이진 트리 표현의 단점 보완</li></ul></li> <li><p>연결 자료구조를 이용한 이진 트리의 이해와 표현</p> <ul><li>이진 트리의 모든 노드는 최대 2개의 자식 노드를 가지므로 일정한 구조의 단순 연결 List 노드를 사용하여 구현</li></ul></li></ol> <h4 id="ex-연결-리스트를-이용하여-트리를-표현한-예제"><a href="#ex-연결-리스트를-이용하여-트리를-표현한-예제" class="header-anchor">#</a> ex) 연결 리스트를 이용하여 트리를 표현한 예제</h4> <div class="language- extra-class"><pre class="language-text"><code>----------------------------
  left  |  데이터  |  right 
----------------------------
왼쪽 자식노드       오른쪽 자식노드
</code></pre></div><br> <h2 id="_4-binary-search-tree"><a href="#_4-binary-search-tree" class="header-anchor">#</a> 4. Binary Search Tree</h2> <h3 id="binary-search-tree의-특징"><a href="#binary-search-tree의-특징" class="header-anchor">#</a> Binary Search Tree의 특징</h3> <ol><li>탐색작업을 효율적으로 하기 위한 자료구조</li> <li>모든 원소는 서로 다른 유일한 키를 가짐</li> <li>key(왼쪽 서브트리) &lt; key(루트 노드) &lt; key(오른쪽 서브트리)</li> <li>왼쪽 서브트리와 오른쪽 서브트리라도 이진 탐색 트리임</li> <li>중위 순회하면 오름차순으로 정렬된 값을 얻을 수 있음</li></ol> <h3 id="binary-search-tree의-연산"><a href="#binary-search-tree의-연산" class="header-anchor">#</a> Binary Search Tree의 연산</h3> <h4 id="탐색-연산"><a href="#탐색-연산" class="header-anchor">#</a> 탐색 연산</h4> <ol><li><p>루트에서 시작</p></li> <li><p>탐색할 키 값 x를 루트 노드의 키 값과 비교</p></li></ol> <ul><li>키값 x = 루트 노드의 키값: 원하는 원소를 찾았으므로 탐색 연산 성공</li> <li>키값 x &lt; 루트 노드의 키값: 루트 노드의 왼쪽 서브트리에 대해서 탐색 연산 수행</li> <li>키값 x &gt; 루트 노드의 키값: 루트 노드의 오른쪽 서브트리에 대해서 탐색 연산 수행</li></ul> <ol start="3"><li>서브트리에 대해서 순환적으로 탐색 연산을 반복</li></ol> <h4 id="삽입-연산"><a href="#삽입-연산" class="header-anchor">#</a> 삽입 연산</h4> <ol><li>먼저 탐색 연산을 수행</li></ol> <ul><li>삽입할 원소와 같은 원소가 트리에 있으면 삽입할 수 없으므로, 같은 원소가 트리에 있는지 탐색하여 확인</li> <li>탐색에서 탐색 실패가 결정되는 위치가 삽입 위치가 됨</li></ul> <ol start="2"><li>탐색 실패한 위치에 원소를 삽입</li></ol> <h3 id="binary-search-tree의-성능"><a href="#binary-search-tree의-성능" class="header-anchor">#</a> Binary Search Tree의 성능</h3> <ol><li>탐색(Searching), 삽입(Insertion), 삭제(Deletion) 시간은 트리의 높이에 좌우 됨</li></ol> <ul><li>O(h), h: BST의 깊이(height)</li></ul> <ol start="2"><li>평균의 경우</li></ol> <ul><li>이진 트리가 균형적으로 생성되어 있는 경우</li> <li>O(logn)</li></ul> <ol start="3"><li>최악의 경우</li></ol> <ul><li>한쪽으로 치우친 경사 이진 트리의 경우</li> <li>O(n)</li> <li>순차탐색과 시간복잡도가 같음</li></ul> <h3 id="검색-알고리즘의-비교"><a href="#검색-알고리즘의-비교" class="header-anchor">#</a> 검색 알고리즘의 비교</h3> <ol><li>리스트에서의 순차 검색: O(n)</li> <li>정렬된 리스트에서의 순차 검색: O(n)</li> <li>정렬된 리스트에서의 이진 검색: O(logn)</li> <li>이진 탐색 트리에서의 평균: O(logn)</li></ol> <ul><li>최악의 경우: O(n)</li> <li>완전 이진 트리 또는 균형 트리로 바꿀 수 있다면 최악의 경우를 없앨 수 있음
<ul><li>새로운 원소를 삽입할 때 삽입 시간을 줄임</li> <li>평균과 최악의 시간이 같음 O(logn)</li></ul></li></ul> <ol start="5"><li>해쉬 검색: O(1)</li></ol> <br> <h2 id="_5-heap"><a href="#_5-heap" class="header-anchor">#</a> 5. Heap</h2> <h3 id="heap의-특징"><a href="#heap의-특징" class="header-anchor">#</a> Heap의 특징</h3> <p><code>완전 이진 트리에 있는 노드</code> 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조</p> <ul><li><p><code>최대 힙(Max heap)</code></p> <ul><li>키 값이 <code>가장 큰 노드를 찾기 위한 완전 이진 트리</code></li> <li>부모 노드의 키값 &gt; 자식 노드의 키값</li> <li>루트 노드: 키값이 가장 큰 노드</li></ul></li> <li><p><code>최소 힙(Min heap)</code></p> <ul><li>키 값이 <code>가장 작은 노드를 찾기 위한 완전 이진 트리</code></li> <li>부모 노드의 키값 &lt; 자식 노드의 키값</li> <li>루트 노드: 키값이 가장 작은 노드</li></ul></li></ul> <h3 id="heap의-연산"><a href="#heap의-연산" class="header-anchor">#</a> Heap의 연산</h3> <h4 id="삽입-연산-2"><a href="#삽입-연산-2" class="header-anchor">#</a> 삽입 연산</h4> <ol><li>삽입 전의 힙</li> <li>삽입 할 자리 확장</li> <li>확장한 자리에 삽입할 원소 저장</li></ol> <h4 id="삭제-연산"><a href="#삭제-연산" class="header-anchor">#</a> 삭제 연산</h4> <ol><li>힙에서는 <code>루트 노드의 원소만을 삭제</code>할 수 있음</li> <li>루트 노드의 원소만을 삭제하여 반환</li> <li>힙의 종류에 따라 <code>최대값 또는 최소값</code>을 구할 수 있음</li></ol> <ul><li>이를 이용하여 우선순위 큐를 힙으로 구현할 수 있음</li></ul> <h4 id="ex-힙에서의-삭제-연산-예제"><a href="#ex-힙에서의-삭제-연산-예제" class="header-anchor">#</a> ex) 힙에서의 삭제 연산 예제</h4> <ol><li>루트 노드의 원소 삭제</li> <li>마지막 노드를 루트 노드 위치로 이동</li> <li>삽입노드와 자식노드를 비교하여 자리 바꾸기</li> <li>자리 확정</li></ol> <br> <h2 id="reference-additional-resources"><a href="#reference-additional-resources" class="header-anchor">#</a> Reference &amp; Additional Resources</h2> <blockquote><p>SW Expert Academy</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">4/10/2020, 2:46:43 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/TIL/SWEA/1-7. Linked List.html" class="prev">
        Linked List
      </a></span> <span class="next"><a href="/TIL/SWEA/1-9. 시작하기.html">
        시작하기
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/TIL/assets/js/app.6416d9a2.js" defer></script><script src="/TIL/assets/js/2.170f2245.js" defer></script><script src="/TIL/assets/js/16.605b62a4.js" defer></script><script src="/TIL/assets/js/4.22de8c0b.js" defer></script>
  </body>
</html>
